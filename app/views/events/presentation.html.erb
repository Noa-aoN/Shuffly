<%# filepath: /Users/n/workspace/Shuffly/app/views/events/presentation.html.erb %>
<div class="min-h-screen bg-gray-50 text-gray-900">
  <div class="max-w-6xl mx-auto px-6 pt-2 pb-4">
    <header class="mb-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <div>
            <!-- ロゴ画像（正方形）用スペースのみ（テキスト等は表示しない） -->
            <div class="w-20 h-20 bg-gray-200 rounded-md flex items-center justify-center" aria-hidden="true"></div>
          </div>
        </div>

        <div class="flex items-center gap-3">
          <!-- style selector (for future stylesheet switching) -->
          <div class="mr-3">
            <fieldset id="styleSelector" class="flex items-center gap-2 bg-white border border-gray-200 rounded px-3 py-2">
              <legend class="sr-only">表示スタイル</legend>
              <label class="text-sm text-gray-600 mr-2">表示スタイル</label>
              <div class="flex gap-2 items-center text-sm">
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="simple" class="mr-1" checked> シンプル</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="work" class="mr-1"> ワーク</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="school" class="mr-1"> スクール</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="sports" class="mr-1"> スポーツ</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="party" class="mr-1"> パーティ</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="casino" class="mr-1"> カジノ</label>
              </div>
            </fieldset>
          </div>
        </div>
      </div>

      <!-- tabs (centered) -->
      <nav class="mt-6 border-b border-gray-200">
        <div class="flex gap-8 text-sm justify-center w-full">
          <button data-mode="groups" class="mode-btn pb-3 text-blue-600 border-b-2 border-blue-600">グループ分け</button>
          <button data-mode="order" class="mode-btn pb-3 text-gray-600 hover:text-gray-800">順番決め</button>
          <button data-mode="roles" class="mode-btn pb-3 text-gray-600 hover:text-gray-800">役割決め</button>
        </div>
      </nav>
    </header>

    <!-- イベントタイトル（あれば大きく表示） -->
    <div id="event-title-wrap" class="text-center mb-4">
      <h1 id="event-title" class="text-3xl font-extrabold"></h1>
    </div>

    <main>
      <div id="pres-content" class="grid grid-cols-1 gap-4">
        <!-- large visible area (white rounded dashed box) -->
        <section class="bg-white rounded-lg border-2 border-dashed border-gray-300 p-6 flex flex-col items-center justify-center min-h-[200px]">
          <div class="text-center max-w-3xl w-full">
            <h2 id="display-subtitle" class="text-xl font-semibold mb-2">シャッフル結果</h2>
            <p id="display-hint" class="text-sm text-gray-500">結果はここに表示されます。</p>

            <div id="display-area" class="mt-4 w-full bg-black rounded-md overflow-auto"
                 style="max-height: calc(100vh - 220px); min-height: 280px;">
              <!-- display wrapper: auto-resizes to window via max-height; content scrolls when long -->
              <div id="display-inner" class="w-full h-full flex items-center justify-center p-6">
                <!-- large display used by script — initially black and empty until reveal -->
                <pre id="display-item" class="w-full text-center whitespace-pre-wrap leading-relaxed m-0 text-white"
                     style="font-family: inherit; font-size: 1.75rem;"></pre>
              </div>
            </div>

            <!-- 履歴下の結果表示は削除しました -->
          </div>
        </section>

        <!-- controls centered under the big box -->
        <div class="flex flex-col sm:flex-row justify-center gap-4 mt-2">
          <button id="btn-hide-results" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">結果非表示</button>
          <button id="btn-prev-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">前の表示</button>
          <button id="btn-step-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">1件表示</button>
          <button id="btn-next-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">後の表示</button>
          <button id="btn-reveal" class="px-6 py-3 bg-blue-600 text-white rounded shadow">一括表示</button>
        </div>

        <!-- history navigation (centered, link style; stacks vertically on small screens) -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-4">
          <a href="#" id="btn-prev-snapshot" class="text-sm text-blue-600 hover:underline">◀︎ 履歴</a>
          <span id="snapshot-index" class="text-sm text-gray-500"></span>
          <a href="#" id="btn-next-snapshot" class="text-sm text-blue-600 hover:underline">履歴 ▶︎</a>
        </div>

        <!-- hidden compact list for presenter (kept but visually subtle) -->
        <div id="list-compact" class="hidden md:block text-sm text-gray-700"></div>

        <!-- 移動したリンクスタイルの操作（ページ末尾に表示） -->
        <div class="mt-2 text-center">
          <a id="btn-back-to-settings" href="#" class="text-sm text-blue-600 hover:underline mr-4">新規イベント作成</a>
          <a id="btn-close" href="#" class="text-sm text-blue-600 hover:underline">このページを閉じる</a>
        </div>
      </div>
    </main>
  </div>
</div>

<script>
(function(){
  function safeParse(v){
    if(!v) return null;
    if(typeof v === 'object') return v;
    try { return JSON.parse(v); } catch(e) {
      try { return JSON.parse(decodeURIComponent(v)); } catch(e){ return null; }
    }
  }
  function getParam(name){
    try{ const params = new URLSearchParams(window.location.search); return params.has(name) ? params.get(name) : null; }catch(e){ return null; }
  }

  // load payload (query first, then localStorage)
  let payload = null;
  try {
    const members_raw = getParam('members_json') || getParam('membersJson') || null;
    const results_raw = getParam('results_json') || getParam('resultsJson') || null;
    const order_raw = getParam('order_json') || getParam('orderJson') || null;
    const settings_raw = getParam('settings_json') || getParam('settingsJson') || null;
    const history_raw = getParam('history_json') || getParam('historyJson') || null;
    const title_raw = (new URLSearchParams(window.location.search)).get('title') || null;

    if(members_raw || results_raw || order_raw || settings_raw || history_raw || title_raw){
      payload = {
        members_json: safeParse(members_raw),
        results_json: safeParse(results_raw),
        order_json: safeParse(order_raw),
        settings_json: safeParse(settings_raw),
        history_json: safeParse(history_raw),
        title: title_raw || ''
      };
    }
  } catch(e){ payload = null; }

  if(!payload){
    try {
      const raw = localStorage.getItem('presentation_shuffly_event') || localStorage.getItem('pending_shuffly_event');
      if(raw){
        const p = safeParse(raw) || JSON.parse(raw);
        payload = {
          members_json: safeParse(p.members_json) || p.members_json || null,
          results_json: safeParse(p.results_json) || p.results_json || null,
          order_json: safeParse(p.order_json) || p.order_json || null,
          settings_json: safeParse(p.settings_json) || p.settings_json || null,
          history_json: safeParse(p.history_json) || p.history_json || null,
          title: p.title || ''
        };
      }
    } catch(e){ /* ignore */ }
  }

  if(!payload) payload = { members_json:null, results_json:null, order_json:null, settings_json:null, history_json:null, title:'' };

  // DOM refs
  const eventTitleEl = document.getElementById('event-title');
  const titleEl = document.querySelector('h1') || document.getElementById('pres-title');
  const displaySubtitle = document.getElementById('display-subtitle');
  const displayItem = document.getElementById('display-item');
  const displayInner = document.getElementById('display-inner');
  const displayArea = document.getElementById('display-area');
  const listCompact = document.getElementById('list-compact');
  const snapshotIndexEl = document.getElementById('snapshot-index');
  const prevSnapshotBtn = document.getElementById('btn-prev-snapshot');
  const nextSnapshotBtn = document.getElementById('btn-next-snapshot');
  const btnHideResults = document.getElementById('btn-hide-results');

  if(eventTitleEl) {
    if(payload.title && payload.title.trim() !== '') {
      eventTitleEl.textContent = payload.title;
      eventTitleEl.classList.remove('hidden');
    } else {
      eventTitleEl.textContent = '';
      eventTitleEl.classList.add('hidden');
    }
  }

  if(titleEl) titleEl.textContent = payload.title || document.title || 'プレゼンテーション';

  // prepare data structures for modes
  function normalizeGroups(results){
    if(!results) return [];
    if(results.groups && typeof results.groups === 'object'){
      const names = results.group_names || results.groupNames || {};
      const keys = Object.keys(results.groups);
      return keys.map(k => ({ label: names[k] || k, members: Array.isArray(results.groups[k]) ? results.groups[k] : [] }));
    }
    if(Array.isArray(results)){
      return results.map((g,i) => {
        if(typeof g === 'string') return { label: `Group ${i+1}`, members: [g] };
        if(Array.isArray(g)) return { label: `Group ${i+1}`, members: g };
        if(g && (g.name || g.label)) return { label: g.name || g.label, members: g.members || [] };
        return { label: `Group ${i+1}`, members: [] };
      });
    }
    return [];
  }

  const rawResults = payload.results_json;
  const groupsList = normalizeGroups(rawResults);
  const orderList = (() => {
    const o = payload.order_json || payload.orderJson || [];
    if(Array.isArray(o)) return o.map((it,i) => (typeof it === 'string' ? { name: it } : it));
    return [];
  })();
  const rolesList = (() => {
    const s = payload.settings_json || payload.settingsJson || {};
    if(s && Array.isArray(s.role_assignments)) return s.role_assignments.map(r => ({ name: r.name, role: r.role }));
    if(s && s.roles && typeof s.roles === 'object') return Object.keys(s.roles).map(k => ({ name: k, role: s.roles[k] }));
    return [];
  })();

  // parse history entries into groups (try to respect assigned group tags like #1A)
  function parseHistoryToGroups(raw){
    if(!raw) return [];
    let lines = [];
    if(Array.isArray(raw)) {
      lines = raw.map(r => (typeof r === 'string' ? r : (r.name || JSON.stringify(r))));
    } else if(typeof raw === 'string'){
      lines = raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    } else {
      return [];
    }
    const groupsMap = {};
    for(const line of lines){
      const name = line.split('#')[0].trim();
      const m = line.match(/#\d+([A-Z])$/);
      const id = m ? m[1] : null;
      const key = id || 'A';
      if(!groupsMap[key]) groupsMap[key]=[];
      groupsMap[key].push(name);
    }
    const keys = Object.keys(groupsMap).sort();
    return keys.map(k => ({ label: `グループ ${k}`, members: groupsMap[k] }));
  }

  // snapshot/history handling
  let history = [];
  if(Array.isArray(payload.history_json)) history = payload.history_json.slice();
  else if(typeof payload.history_json === 'string'){
    const parsed = safeParse(payload.history_json);
    if(Array.isArray(parsed)) history = parsed;
  }
  if(history.length === 0 && payload.members_json && Array.isArray(payload.members_json)){
    history = [ payload.members_json ];
  }
  let historyIdx = history.length > 0 ? history.length - 1 : -1;
  function updateSnapshotUI(){
    if(historyIdx < 0 || history.length === 0){
      snapshotIndexEl.textContent = '';
      if(prevSnapshotBtn) prevSnapshotBtn.classList.add('opacity-50');
      if(nextSnapshotBtn) nextSnapshotBtn.classList.add('opacity-50');
    } else {
      snapshotIndexEl.textContent = ` ${historyIdx+1}/${history.length}`;
      if(prevSnapshotBtn) prevSnapshotBtn.classList.toggle('opacity-50', historyIdx <= 0);
      if(nextSnapshotBtn) nextSnapshotBtn.classList.toggle('opacity-50', historyIdx >= history.length - 1);
    }
  }

  // attach history prev/next handlers (link style)
  if(prevSnapshotBtn) prevSnapshotBtn.addEventListener('click', (e) => {
    if(e) e.preventDefault();
    // make display area black immediately
    revealed = false;
    bulkView = false;
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayItem.textContent = '';
    displayInner.style.alignItems = 'center';
    if(historyIdx > 0){ historyIdx--; updateSnapshotUI();
      // if viewing groups, reconstruct groupsList from history entry
      if(mode === 'groups'){
        const entry = history[historyIdx];
        const reconstructed = parseHistoryToGroups(entry);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, reconstructed);
        counts.groups = groupsList.length;
        indices.groups = 0;
        rebuildListCompact();
        // show reconstructed groups as current (single-group view hidden until user presses a display button)
        revealed = true;
        bulkView = false;
        updateDisplay();
      }
    }
  });
  if(nextSnapshotBtn) nextSnapshotBtn.addEventListener('click', (e) => {
    if(e) e.preventDefault();
    // make display area black immediately
    revealed = false;
    bulkView = false;
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayItem.textContent = '';
    displayInner.style.alignItems = 'center';
    if(historyIdx < history.length - 1){ historyIdx++; updateSnapshotUI();
      if(mode === 'groups'){
        const entry = history[historyIdx];
        const reconstructed = parseHistoryToGroups(entry);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, reconstructed);
        counts.groups = groupsList.length;
        indices.groups = 0;
        rebuildListCompact();
        revealed = true;
        bulkView = false;
        updateDisplay();
      }
    }
  });
  updateSnapshotUI();

  // mode state and per-mode index
  let mode = 'groups'; // groups | order | roles
  const modeBtns = Array.from(document.querySelectorAll('.mode-btn'));
  const indices = { groups: 0, order: 0, roles: 0 };
  const counts = { groups: groupsList.length, order: orderList.length, roles: rolesList.length };

  // control flags
  let revealed = false;
  let bulkView = false; // true when 一括表示 is active

  function setMode(m){
    mode = m;
    modeBtns.forEach(b => {
      b.classList.toggle('text-blue-600', b.dataset.mode === m);
      b.classList.toggle('border-b-2', b.dataset.mode === m);
      b.classList.toggle('border-blue-600', b.dataset.mode === m);
      b.classList.toggle('text-gray-600', b.dataset.mode !== m);
    });
    if(m === 'groups') displaySubtitle.textContent = 'グループ（1グループずつ表示）';
    if(m === 'order') displaySubtitle.textContent = '順番（1件ずつ表示）';
    if(m === 'roles') displaySubtitle.textContent = '役職（1件ずつ表示）';
    rebuildListCompact();

    // If no results exist for this mode -> show "未実行"
    if((counts[m] || 0) === 0){
      bulkView = false;
      revealed = false;
      // show a neutral "未実行" (exception to black initial state)
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280'; // gray-500
      displayItem.style.fontSize = '1rem';
      displayItem.textContent = '未実行';
      updateControls();
      return;
    }

    // otherwise, keep initial black state until a display control is pressed
    revealed = false;
    bulkView = false;
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayItem.textContent = '';
    displayItem.style.color = '#FFFFFF';
    displayItem.style.fontSize = '1.75rem';
    updateControls();
  }
  modeBtns.forEach(b => b.addEventListener('click', ()=> setMode(b.dataset.mode)));

  function rebuildListCompact(){
    if(!listCompact) return;
    listCompact.innerHTML = '';
    if(mode === 'groups'){
      groupsList.forEach((g,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${g.label} (${g.members.length})`;
        el.addEventListener('click', () => { indices.groups = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(groupsList.length === 0) listCompact.textContent = '';
    } else if(mode === 'order'){
      orderList.forEach((o,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${o.name || JSON.stringify(o)}`;
        el.addEventListener('click', () => { indices.order = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(orderList.length === 0) listCompact.textContent = '';
    } else if(mode === 'roles'){
      rolesList.forEach((r,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${r.name || ''} ${r.role ? '– ' + r.role : ''}`;
        el.addEventListener('click', () => { indices.roles = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(rolesList.length === 0) listCompact.textContent = '';
    }
    counts.groups = groupsList.length; counts.order = orderList.length; counts.roles = rolesList.length;
  }

  // display control refs
  const btnReveal = document.getElementById('btn-reveal');
  const btnPrevItem = document.getElementById('btn-prev-item');
  const btnNextItem = document.getElementById('btn-next-item');
  const btnStepItem = document.getElementById('btn-step-item');

  function updateControls(){
    const len = counts[mode] || 0;
    const idx = indices[mode] || 0;
    if(btnPrevItem) btnPrevItem.disabled = !revealed || idx <= 0;
    if(btnNextItem) btnNextItem.disabled = !revealed || idx >= len - 1;
    if(btnStepItem) btnStepItem.disabled = revealed && idx >= len - 1;
    // 「一括表示」は常に表示したいので非表示制御は行わない
  }

  function formatGroupForDisplay(g){
    const members = Array.isArray(g.members) ? g.members : [];
    const header = (g.label && g.label !== '') ? `${g.label}（${members.length}名）` : `（${members.length}名）`;
    const lines = [header, ''];
    members.forEach(m => {
      if(typeof m === 'string') lines.push(m);
      else if(m && (m.name || m.full_name)) lines.push(m.name || m.full_name);
      else lines.push(JSON.stringify(m));
    });
    return lines.join('\n');
  }

  function formatOrderForDisplay(o){
    if(!o) return '';
    if(typeof o === 'string') return o;
    if(o.name) return o.name;
    return JSON.stringify(o);
  }

  function formatRoleForDisplay(r){
    if(!r) return '';
    return (r.name || '') + (r.role ? ` — ${r.role}` : '');
  }

  function renderBulkList(){
    // render all items for current mode in a consistent font size; allow scroll via display-area
    let lines = [];
    if(mode === 'groups'){
      groupsList.forEach((g,i) => {
        lines.push(`${i+1}. ${g.label}（${(g.members||[]).length}名）`);
        (g.members||[]).forEach(m => lines.push(`  - ${typeof m === 'string' ? m : (m.name || m.full_name || JSON.stringify(m))}`));
        lines.push(''); // gap
      });
    } else if(mode === 'order'){
      orderList.forEach((o,i) => {
        lines.push(`${i+1}. ${formatOrderForDisplay(o)}`);
      });
    } else if(mode === 'roles'){
      rolesList.forEach((r,i) => {
        lines.push(`${i+1}. ${formatRoleForDisplay(r)}`);
      });
    }
    // uniform font-size for bulk
    displayArea.classList.remove('bg-black');
    displayArea.classList.add('bg-white');
    displayItem.style.color = '#111827'; // gray-900
    displayItem.style.fontSize = '1rem';
    displayItem.textContent = lines.join('\n');
    // ensure inner alignment uses top-left for lists
    displayInner.style.alignItems = 'flex-start';
  }

  function updateDisplay(){
    const len = counts[mode] || 0;
    const idx = indices[mode] || 0;

    // If no results -> handled in setMode but keep fallback
    if(len === 0){
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280';
      displayItem.style.fontSize = '1rem';
      displayItem.textContent = '未実行';
      updateControls();
      return;
    }

    if(!revealed){
      // initial black state (no content shown)
      displayArea.classList.add('bg-black');
      displayArea.classList.remove('bg-white');
      displayInner.style.alignItems = 'center';
      displayItem.style.color = '#FFFFFF';
      displayItem.style.fontSize = '1.75rem';
      displayItem.textContent = '';
      updateControls();
      return;
    }

    // revealed path
    if(bulkView){
      renderBulkList();
    } else {
      // single-item view
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayInner.style.alignItems = 'center';
      displayItem.style.color = '#111827';
      displayItem.style.fontSize = '1.75rem';

      if(mode === 'groups'){
        displayItem.textContent = formatGroupForDisplay(groupsList[idx] || {});
      } else if(mode === 'order'){
        // show position + member name together; for order items that may include member lists, handle both cases
        const item = orderList[idx] || {};
        let namePart = formatOrderForDisplay(item);
        // if item contains members array, render them under the position
        if(item && Array.isArray(item.members) && item.members.length > 0){
          const lines = [`${idx+1}. ${namePart}`, ''];
          item.members.forEach(m => lines.push(typeof m === 'string' ? m : (m.name || m.full_name || JSON.stringify(m))));
          displayItem.textContent = lines.join('\n');
        } else {
          displayItem.textContent = `${idx+1}. ${namePart}`;
        }
      } else if(mode === 'roles'){
        displayItem.textContent = formatRoleForDisplay(rolesList[idx] || {});
      }
    }

    updateControls();
  }

  function revealCurrent(asBulk){
    revealed = true;
    bulkView = !!asBulk;
    updateDisplay();
  }
  function hideAll(){
    revealed = false;
    bulkView = false;
    displayItem.textContent = '';
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayInner.style.alignItems = 'center';
    updateControls();
  }

  if(btnReveal) btnReveal.addEventListener('click', () => {
    // no-op if already bulk-viewing
    if(bulkView) return;
    revealCurrent(true);
  });
  if(btnHideResults) btnHideResults.addEventListener('click', () => {
    hideAll();
  });
  if(btnPrevItem) btnPrevItem.addEventListener('click', () => {
    if((counts[mode]||0) === 0){
      // nothing
      return;
    }
    if(indices[mode] > 0){ indices[mode]--; revealCurrent(false); }
  });
  if(btnNextItem) btnNextItem.addEventListener('click', () => {
    if((counts[mode]||0) === 0) return;
    if(indices[mode] < (counts[mode]-1)){ indices[mode]++; revealCurrent(false); }
  });
  if(btnStepItem) btnStepItem.addEventListener('click', () => {
    // step: reveal one item and advance index by one each click (or reveal current if not revealed yet)
    if((counts[mode]||0) === 0){
      // when there are no items, show "未実行" even if the display area was black
      revealed = true;
      bulkView = false;
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280';
      displayItem.style.fontSize = '1rem';
      displayItem.textContent = '未実行';
      updateControls();
      return;
    }
    if(!revealed){
      // show current index
      revealCurrent(false);
    } else if(indices[mode] < (counts[mode]-1)){
      indices[mode]++; revealCurrent(false);
    } else {
      // at end: reveal last
      indices[mode] = Math.max(0, counts[mode]-1);
      revealCurrent(false);
    }
  });

  // init (do not reveal anything on load)
  setMode('groups');
  rebuildListCompact();
  updateDisplay();

  // --- receive updates from authoring window (BroadcastChannel) and fallback via storage ---
  try {
    if (typeof BroadcastChannel !== 'undefined') {
      const bc = new BroadcastChannel('shuffly_channel');
      bc.onmessage = (ev) => {
        try {
          const data = ev.data;
          if(!data) return;
          if(data.type === 'init' || data.type === 'update'){
            const p = data.payload || {};
            // merge/override payload fields when provided
            payload = {
              members_json: safeParse(p.members_json) || p.members_json || payload.members_json,
              results_json: safeParse(p.results_json) || p.results_json || payload.results_json,
              order_json: safeParse(p.order_json) || p.order_json || payload.order_json,
              settings_json: safeParse(p.settings_json) || p.settings_json || payload.settings_json,
              history_json: safeParse(p.history_json) || p.history_json || payload.history_json,
              title: p.title || payload.title
            };

            // update event title if changed
            if(eventTitleEl){
              if(payload.title && payload.title.trim() !== ''){
                eventTitleEl.textContent = payload.title;
                eventTitleEl.classList.remove('hidden');
              } else {
                eventTitleEl.textContent = '';
                eventTitleEl.classList.add('hidden');
              }
            }

            // rebuild lists
            const newGroups = normalizeGroups(payload.results_json);
            groupsList.length = 0; Array.prototype.push.apply(groupsList, newGroups);

            const newOrder = (Array.isArray(payload.order_json) ? payload.order_json.map(it => (typeof it === 'string' ? {name:it} : it)) : []);
            orderList.length = 0; Array.prototype.push.apply(orderList, newOrder);

            const s = payload.settings_json || (payload.settingsJson || {});
            const newRoles = (s && Array.isArray(s.role_assignments)) ? s.role_assignments.map(r=>({name:r.name, role:r.role})) : (s && s.roles && typeof s.roles === 'object' ? Object.keys(s.roles).map(k=>({name:k, role:s.roles[k]})) : []);
            rolesList.length = 0; Array.prototype.push.apply(rolesList, newRoles);

            // history
            const parsedHistory = Array.isArray(payload.history_json) ? payload.history_json.slice() : (typeof payload.history_json === 'string' ? (safeParse(payload.history_json) || []) : []);
            history = parsedHistory.length ? parsedHistory : history;
            historyIdx = history.length > 0 ? history.length - 1 : -1;

            // ensure indices remain valid
            if(indices.groups >= groupsList.length) indices.groups = Math.max(0, groupsList.length-1);
            if(indices.order >= orderList.length) indices.order = Math.max(0, orderList.length-1);
            if(indices.roles >= rolesList.length) indices.roles = Math.max(0, rolesList.length-1);

            rebuildListCompact();
            updateSnapshotUI();
            updateDisplay();

            if(titleEl) titleEl.textContent = payload.title || document.title || 'プレゼンテーション';
          }
        } catch(err){
          console.warn('shuffly_channel handler error', err);
        }
      };
    }
  } catch(e){
    console.warn('BroadcastChannel not available', e);
  }

  // storage fallback: listen for presentation_shuffly_event updates
  window.addEventListener('storage', function(e){
    if(!e || !e.key) return;
    if(e.key === 'presentation_shuffly_event'){
      try {
        const raw = e.newValue;
        if(!raw) return;
        const p = safeParse(raw) || JSON.parse(raw);
        payload = {
          members_json: safeParse(p.members_json) || p.members_json || payload.members_json,
          results_json: safeParse(p.results_json) || p.results_json || payload.results_json,
          order_json: safeParse(p.order_json) || p.order_json || payload.order_json,
          settings_json: safeParse(p.settings_json) || p.settings_json || payload.settings_json,
          history_json: safeParse(p.history_json) || p.history_json || payload.history_json,
          title: p.title || payload.title
        };
        // update event title if changed
        if(eventTitleEl){
          if(payload.title && payload.title.trim() !== ''){
            eventTitleEl.textContent = payload.title;
            eventTitleEl.classList.remove('hidden');
          } else {
            eventTitleEl.textContent = '';
            eventTitleEl.classList.add('hidden');
          }
        }
        const newGroups = normalizeGroups(payload.results_json);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, newGroups);
        const newOrder = (Array.isArray(payload.order_json) ? payload.order_json.map(it => (typeof it === 'string' ? {name:it} : it)) : []);
        orderList.length = 0; Array.prototype.push.apply(orderList, newOrder);
        const s = payload.settings_json || (payload.settingsJson || {});
        const newRoles = (s && Array.isArray(s.role_assignments)) ? s.role_assignments.map(r=>({name:r.name, role:r.role})) : (s && s.roles && typeof s.roles === 'object' ? Object.keys(s.roles).map(k=>({name:k, role:s.roles[k]})) : []);
        rolesList.length = 0; Array.prototype.push.apply(rolesList, newRoles);
        const parsedHistory = Array.isArray(payload.history_json) ? payload.history_json.slice() : (typeof payload.history_json === 'string' ? (safeParse(payload.history_json) || []) : []);
        history = parsedHistory.length ? parsedHistory : history;
        historyIdx = history.length > 0 ? history.length - 1 : -1;
        if(indices.groups >= groupsList.length) indices.groups = Math.max(0, groupsList.length-1);
        if(indices.order >= orderList.length) indices.order = Math.max(0, orderList.length-1);
        if(indices.roles >= rolesList.length) indices.roles = Math.max(0, rolesList.length-1);
        rebuildListCompact();
        updateSnapshotUI();
        updateDisplay();
        if(titleEl) titleEl.textContent = payload.title || document.title || 'プレゼンテーション';
      } catch(err){ /* ignore parse errors */ }
    }
  });

  // back -> restore pending inputs and go to new (link-style handler)
  const backBtn = document.getElementById('btn-back-to-settings');
  if(backBtn) backBtn.addEventListener('click', function(e){
    if(e) e.preventDefault();
    try{
      const preview = {
        members_json: (typeof payload.members_json === 'string') ? payload.members_json : (payload.members_json ? JSON.stringify(payload.members_json) : ''),
        results_json: (typeof payload.results_json === 'string') ? payload.results_json : (payload.results_json ? JSON.stringify(payload.results_json) : ''),
        order_json: (typeof payload.order_json === 'string') ? payload.order_json : (payload.order_json ? JSON.stringify(payload.order_json) : ''),
        settings_json: (typeof payload.settings_json === 'string') ? payload.settings_json : (payload.settings_json ? JSON.stringify(payload.settings_json) : ''),
        history_json: (typeof payload.history_json === 'string') ? payload.history_json : (payload.history_json ? JSON.stringify(payload.history_json) : ''),
        title: payload.title || ''
      };
      localStorage.setItem('pending_shuffly_event', JSON.stringify(preview));
    }catch(e){}
    window.location.href = "<%= new_event_path %>";
  });

  const closeBtn = document.getElementById('btn-close');
  if(closeBtn) closeBtn.addEventListener('click', function(e){
    if(e) e.preventDefault();
    if(window.opener) window.close(); else window.location.href = "<%= root_path %>";
  });

  // keyboard
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') document.getElementById('btn-back-to-settings').click();
    if(e.key === 'ArrowLeft') document.getElementById('btn-prev-item').click();
    if(e.key === 'ArrowRight') document.getElementById('btn-next-item').click();
    if(e.key === ' '){ e.preventDefault(); revealed ? hideAll() : revealCurrent(false); }
  });

  // style selector persistence (no functional effect now)
  try {
    const radios = document.querySelectorAll('input[name="presentationStyle"]');
    const stored = localStorage.getItem('presentation_style');
    if(stored){
      radios.forEach(r => { if(r.value === stored) r.checked = true; });
    }
    radios.forEach(r => r.addEventListener('change', (e) => {
      try { localStorage.setItem('presentation_style', e.target.value); } catch(e){}
    }));
  } catch(e){}
})();
</script>