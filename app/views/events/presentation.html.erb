<%# filepath: /Users/n/workspace/Shuffly/app/views/events/presentation.html.erb %>
<div class="min-h-screen bg-gray-50 text-gray-900">
  <div class="max-w-7xl mx-auto px-6 pt-2 pb-4">
    <!-- イベントタイトル -->
    <div id="event-title-wrap" class="text-center mb-4">
      <h1 id="event-title" class="text-3xl font-extrabold border rounded-md px-4 py-2 bg-white inline-block"></h1>
    </div>

    <header class="mb-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <!-- ロゴ削除（スペース詰め） -->
        </div>

        <div class="flex items-center gap-3">
          <!-- 表示スタイルは後で履歴の下に移動 -->
        </div>
      </div>

      <!-- tabs (centered) -->
      <nav class="mt-6 border-b border-gray-200">
        <div class="flex gap-8 text-sm justify-center w-full">
          <button data-mode="groups" class="mode-btn pb-3 text-blue-600 border-b-2 border-blue-600">グループ分け</button>
          <button data-mode="order" class="mode-btn pb-3 text-gray-600 hover:text-gray-800">順番決め</button>
          <button data-mode="roles" class="mode-btn pb-3 text-gray-600 hover:text-gray-800">役割決め</button>
        </div>
      </nav>
    </header>

    <main>
      <div id="pres-content" class="grid grid-cols-1 gap-4">
        <!-- large visible area (white rounded dashed box) -->
        <section class="bg-white rounded-lg border-2 border-dashed border-gray-300 p-6 flex flex-col items-center justify-center min-h-[200px]">
          <div class="text-center max-w-7xl w-full">
            <h2 id="display-subtitle" class="text-xl font-semibold mb-2">シャッフル結果</h2>
            <p id="display-hint" class="text-sm text-gray-500">結果はここに表示されます。</p>

            <div id="display-area" class="relative mt-4 w-full bg-black rounded-md overflow-auto"
                 style="max-height: calc(100vh - 160px); min-height: 60vh;">
              <!-- mini fullscreen button (emoji) at top-right of display area -->
              <button id="btn-mini-fullscreen" class="absolute top-2 right-2 bg-white/10 hover:bg-white/20 text-white rounded px-2 py-1" aria-label="全画面表示">⛶</button>

              <!-- display wrapper: auto-resizes to window via max-height; content scrolls when long -->
              <div id="display-inner" class="w-full h-full flex items-center justify-center p-4">
                <!-- large display used by script — initially black and empty until reveal -->
                <pre id="display-item" class="w-full text-center whitespace-pre-wrap leading-relaxed m-0 text-white"
                     style="font-family: inherit;"></pre>
              </div>
            </div>

            <!-- 履歴下の結果表示は除外 -->
          </div>
        </section>

        <!-- controls centered under the big box (フルスクリーンでも一部は表示される) -->
        <div class="flex flex-col sm:flex-row justify-center gap-4 mt-2">
          <button id="btn-toggle-fullscreen" class="px-3 py-2 bg-white border rounded shadow-sm text-gray-700">全画面</button>
          <button id="btn-hide-results" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">非表示</button>
          <button id="btn-prev-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">前の表示</button>
          <button id="btn-step-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">1件表示</button>
          <button id="btn-next-item" class="px-6 py-3 bg-white border rounded shadow-sm text-gray-700">後の表示</button>
          <button id="btn-reveal" class="px-6 py-3 bg-blue-600 text-white rounded shadow">一括表示</button>
        </div>

        <!-- history navigation (centered, link style; stacks vertically on small screens) -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-4">
          <a href="#" id="btn-prev-snapshot" class="text-sm text-blue-600 hover:underline">◀︎ 履歴</a>
          <span id="snapshot-index" class="text-sm text-gray-500"></span>
          <a href="#" id="btn-next-snapshot" class="text-sm text-blue-600 hover:underline">履歴 ▶︎</a>
        </div>

        <!-- 表示設定（統計表示と同じスタイルに合わせる） -->
        <div class="flex items-center justify-between mb-3 mt-2">
          <h3 class="font-medium"><a href="#" id="btn-toggle-style-settings" class="hover:underline">表示設定</a></h3>
        </div>
        <div id="style-settings" class="hidden">
          <fieldset class="bg-white border rounded-md px-3 py-2 mb-3">
            <legend class="sr-only">表示設定</legend>

            <label class="text-sm text-gray-600 mr-2">表示スタイル</label>
            <div class="flex gap-2 items-center text-sm mt-2">
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="simple" class="mr-1" checked> シンプル</label>
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="work" class="mr-1"> ワーク</label>
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="school" class="mr-1"> スクール</label>
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="sports" class="mr-1"> スポーツ</label>
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="party" class="mr-1"> パーティ</label>
              <label class="inline-flex items-center"><input type="radio" name="presentationStyle" value="casino" class="mr-1"> カジノ</label>
            </div>

            <!-- 演出オプション -->
            <div class="mt-3 text-sm">
              <div class="font-medium mb-1">演出</div>
              <div class="flex gap-3 items-center">
                <label class="inline-flex items-center"><input type="radio" name="presentationPerformance" value="on" class="mr-1" checked> オン</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationPerformance" value="off" class="mr-1"> オフ</label>
              </div>
            </div>

            <!-- 効果音オプション -->
            <div class="mt-3 text-sm">
              <div class="font-medium mb-1">効果音</div>
              <div class="flex gap-3 items-center">
                <label class="inline-flex items-center"><input type="radio" name="presentationSound" value="on" class="mr-1" checked> オン</label>
                <label class="inline-flex items-center"><input type="radio" name="presentationSound" value="off" class="mr-1"> オフ</label>
              </div>
            </div>
          </fieldset>
        </div>

      </div>
    </main>
  </div>
</div>

<!-- flash message (イベント作成ページと同様のスタイル) -->
<div id="flash-message" class="hidden fixed top-6 left-1/2 transform -translate-x-1/2 bg-yellow-300 text-black px-4 py-2 rounded shadow z-50"></div>

<style>
/* fullscreen mode: hide header/footer and make pres-content occupy whole viewport */
.fullscreen-active header { display: none !important; }
.fullscreen-active .mt-2.text-center { display: none !important; } /* hide bottom small footer area if present */
/* support both container sizes */
.fullscreen-active .max-w-6xl,
.fullscreen-active .max-w-7xl { padding-top: 0 !important; padding-bottom: 0 !important; }

/* expand container and display-area width in fullscreen to match viewport */
.fullscreen-active .max-w-7xl {
  max-width: none !important;
  width: 100% !important;
  padding-left: 12px !important;
  padding-right: 12px !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}

.fullscreen-active #pres-content {
  position: fixed;
  inset: 0;
  background: #111827;
  z-index: 1200;
  padding: 24px;
  display: flex;
  flex-direction: column;
  overflow: auto;
}

/* Ensure subtitle/hint are hidden in fullscreen */
.fullscreen-active #display-subtitle,
.fullscreen-active #display-hint {
  display: none !important;
}

/* place event title at top in fullscreen */
.fullscreen-active #event-title-wrap {
  position: fixed !important;
  top: 12px !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  z-index: 1250 !important;
  margin: 0 !important;
}
.fullscreen-active #event-title {
  background: rgba(255,255,255,0.95);
}

/* hide specific controls in fullscreen: keep only 非表示 and mini/fullscreen toggle if desired */
.fullscreen-active .flex.flex-col.sm\\:flex-row.justify-center.gap-4.mt-2 > :not(#btn-hide-results):not(#btn-toggle-fullscreen):not(#btn-mini-fullscreen) {
  display: none !important;
}

.fullscreen-active #display-area {
  background: #111827 !important;
  border-radius: 6px;
  flex: 1 1 auto;
  max-height: none !important;
  width: 100% !important;
  max-width: 100% !important;
  margin: 0 !important;
  box-sizing: border-box;
}
.fullscreen-active #display-item { color: #fff !important; }

/* Responsive font-size for single/bulk display — scales with viewport */
#display-item {
  /* fallback and base scaling */
  font-size: clamp(1rem, 2.5vw + 0.5rem, 2.5rem);
  line-height: 1.2;
}

/* Slightly larger scaling when fullscreen */
.fullscreen-active #display-item {
  font-size: clamp(1.25rem, 4vw + 0.5rem, 4rem) !important;
  line-height: 1.15;
}

/* Make pres-content occupy more viewport height so inner area grows with screen */
#pres-content {
  min-height: calc(100vh - 120px);
}

/* Ensure the top section stretches to use available vertical space */
#pres-content > section {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
}

/* Make display-area expand within the section and scale with viewport */
#display-area {
  flex: 1 1 auto;
  min-height: 60vh;
  max-height: calc(100vh - 160px);
  width: 100%;
  box-sizing: border-box;
}

/* reduce inner padding slightly to gain more visible area */
#display-inner { padding: 1rem; }

/* Ensure the mini fullscreen button (⛶) is always visible and above content */
#btn-mini-fullscreen {
  display: inline-flex !important;
  position: absolute !important;
  top: 8px !important;
  right: 8px !important;
  z-index: 1300 !important;
  font-size: 1rem;
  line-height: 1;
}

/* ensure visible appearance in fullscreen */
.fullscreen-active #btn-mini-fullscreen {
  background: rgba(255,255,255,0.06) !important;
  color: #fff !important;
}

/* mobile adjustments for fullscreen to avoid overflow and maintain layout */
@media (max-width: 640px) {
  .fullscreen-active #pres-content { padding: 12px !important; }
  .fullscreen-active #display-inner { padding: 0.5rem !important; }
  .fullscreen-active #event-title { font-size: 1.125rem !important; padding: 8px 10px !important; }
  /* ensure a readable minimum on small devices */
  #display-item { font-size: clamp(1rem, 4vw + 0.25rem, 2rem) !important; }
}

/* flash helper (no-op beyond placement) */
#flash-message { transition: opacity 180ms ease; }

/* style-settings toggle active state handled via aria-expanded in JS */
</style>

<script>
(function(){
  function safeParse(v){
    if(!v) return null;
    if(typeof v === 'object') return v;
    try { return JSON.parse(v); } catch(e) {
      try { return JSON.parse(decodeURIComponent(v)); } catch(e){ return null; }
    }
  }
  function getParam(name){
    try{ const params = new URLSearchParams(window.location.search); return params.has(name) ? params.get(name) : null; }catch(e){ return null; }
  }

  // load payload (query first, then localStorage)
  let payload = null;
  try {
    const members_raw = getParam('members_json') || getParam('membersJson') || null;
    const results_raw = getParam('results_json') || getParam('resultsJson') || null;
    const order_raw = getParam('order_json') || getParam('orderJson') || null;
    const settings_raw = getParam('settings_json') || getParam('settingsJson') || null;
    const history_raw = getParam('history_json') || getParam('historyJson') || null;
    const title_raw = (new URLSearchParams(window.location.search)).get('title') || null;

    if(members_raw || results_raw || order_raw || settings_raw || history_raw || title_raw){
      payload = {
        members_json: safeParse(members_raw),
        results_json: safeParse(results_raw),
        order_json: safeParse(order_raw),
        settings_json: safeParse(settings_raw),
        history_json: safeParse(history_raw),
        title: title_raw || ''
      };
    }
  } catch(e){ payload = null; }

  if(!payload){
    try {
      const raw = localStorage.getItem('presentation_shuffly_event') || localStorage.getItem('pending_shuffly_event');
      if(raw){
        const p = safeParse(raw) || JSON.parse(raw);
        payload = {
          members_json: safeParse(p.members_json) || p.members_json || null,
          results_json: safeParse(p.results_json) || p.results_json || null,
          order_json: safeParse(p.order_json) || p.order_json || null,
          settings_json: safeParse(p.settings_json) || p.settings_json || null,
          history_json: safeParse(p.history_json) || p.history_json || null,
          title: p.title || ''
        };
      }
    } catch(e){ /* ignore */ }
  }

  if(!payload) payload = { members_json:null, results_json:null, order_json:null, settings_json:null, history_json:null, title:'' };

  // DOM refs
  const eventTitleEl = document.getElementById('event-title');
  const eventTitleWrap = document.getElementById('event-title-wrap');
  const displaySubtitle = document.getElementById('display-subtitle');
  const displayHint = document.getElementById('display-hint');
  const displayItem = document.getElementById('display-item');
  const displayInner = document.getElementById('display-inner');
  const displayArea = document.getElementById('display-area');
  const snapshotIndexEl = document.getElementById('snapshot-index');
  const prevSnapshotBtn = document.getElementById('btn-prev-snapshot');
  const nextSnapshotBtn = document.getElementById('btn-next-snapshot');
  const btnHideResults = document.getElementById('btn-hide-results');
  const btnToggleFullscreen = document.getElementById('btn-toggle-fullscreen');
  const btnMiniFullscreen = document.getElementById('btn-mini-fullscreen');
  const btnToggleStyleSettings = document.getElementById('btn-toggle-style-settings');
  const styleSettingsDiv = document.getElementById('style-settings');
  const flashMessageEl = document.getElementById('flash-message');

  if(eventTitleEl) {
    if(payload.title && payload.title.trim() !== '') {
      eventTitleEl.textContent = payload.title;
      eventTitleEl.classList.remove('hidden');
    } else {
      eventTitleEl.textContent = '';
      eventTitleEl.classList.add('hidden');
    }
  }

  // prepare data structures for modes
  function normalizeGroups(results){
    if(!results) return [];
    if(results.groups && typeof results.groups === 'object'){
      const names = results.group_names || results.groupNames || {};
      const keys = Object.keys(results.groups);
      return keys.map(k => ({ label: names[k] || k, members: Array.isArray(results.groups[k]) ? results.groups[k] : [] }));
    }
    if(Array.isArray(results)){
      return results.map((g,i) => {
        if(typeof g === 'string') return { label: `Group ${i+1}`, members: [g] };
        if(Array.isArray(g)) return { label: `Group ${i+1}`, members: g };
        if(g && (g.name || g.label)) return { label: g.name || g.label, members: g.members || [] };
        return { label: `Group ${i+1}`, members: [] };
      });
    }
    return [];
  }

  const rawResults = payload.results_json;
  const groupsList = normalizeGroups(rawResults);
  const orderList = (() => {
    const o = payload.order_json || payload.orderJson || [];
    if(Array.isArray(o)) return o.map((it,i) => (typeof it === 'string' ? { name: it } : it));
    return [];
  })();
  const rolesList = (() => {
    const s = payload.settings_json || payload.settingsJson || {};
    if(s && Array.isArray(s.role_assignments)) return s.role_assignments.map(r => ({ name: r.name, role: r.role }));
    if(s && s.roles && typeof s.roles === 'object') return Object.keys(s.roles).map(k => ({ name: k, role: s.roles[k] }));
    return [];
  })();

  // snapshot/history handling (no snapshot display under history)
  let history = [];
  if(Array.isArray(payload.history_json)) history = payload.history_json.slice();
  else if(typeof payload.history_json === 'string'){
    const parsed = safeParse(payload.history_json);
    if(Array.isArray(parsed)) history = parsed;
  }
  if(history.length === 0 && payload.members_json && Array.isArray(payload.members_json)){
    history = [ payload.members_json ];
  }
  let historyIdx = history.length > 0 ? history.length - 1 : -1;
  function updateSnapshotUI(){
    if(historyIdx < 0 || history.length === 0){
      snapshotIndexEl.textContent = '';
      if(prevSnapshotBtn) prevSnapshotBtn.classList.add('opacity-50');
      if(nextSnapshotBtn) nextSnapshotBtn.classList.add('opacity-50');
    } else {
      snapshotIndexEl.textContent = ` ${historyIdx+1}/${history.length}`;
      if(prevSnapshotBtn) prevSnapshotBtn.classList.toggle('opacity-50', historyIdx <= 0);
      if(nextSnapshotBtn) nextSnapshotBtn.classList.toggle('opacity-50', historyIdx >= history.length - 1);
    }
  }

  // attach history prev/next handlers (keep behavior but no extra display under history)
  if(prevSnapshotBtn) prevSnapshotBtn.addEventListener('click', (e) => {
    if(e) e.preventDefault();
    revealed = false; bulkView = false;
    displayArea.classList.add('bg-black'); displayArea.classList.remove('bg-white');
    displayItem.textContent = ''; displayInner.style.alignItems = 'center';
    if(historyIdx > 0){ historyIdx--; updateSnapshotUI();
      if(mode === 'groups'){
        const entry = history[historyIdx];
        const reconstructed = parseHistoryToGroups(entry);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, reconstructed);
        counts.groups = groupsList.length;
        indices.groups = 0;
        rebuildListCompact();
        revealed = true; bulkView = false; updateDisplay();
      }
    }
  });
  if(nextSnapshotBtn) nextSnapshotBtn.addEventListener('click', (e) => {
    if(e) e.preventDefault();
    revealed = false; bulkView = false;
    displayArea.classList.add('bg-black'); displayArea.classList.remove('bg-white');
    displayItem.textContent = ''; displayInner.style.alignItems = 'center';
    if(historyIdx < history.length - 1){ historyIdx++; updateSnapshotUI();
      if(mode === 'groups'){
        const entry = history[historyIdx];
        const reconstructed = parseHistoryToGroups(entry);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, reconstructed);
        counts.groups = groupsList.length;
        indices.groups = 0;
        rebuildListCompact();
        revealed = true; bulkView = false; updateDisplay();
      }
    }
  });
  updateSnapshotUI();

  // mode state and per-mode index
  let mode = 'groups'; // groups | order | roles
  const modeBtns = Array.from(document.querySelectorAll('.mode-btn'));
  const indices = { groups: 0, order: 0, roles: 0 };
  const counts = { groups: groupsList.length, order: orderList.length, roles: rolesList.length };

  // control flags
  let revealed = false;
  let bulkView = false; // true when 一括表示 is active

  function setMode(m){
    mode = m;
    modeBtns.forEach(b => {
      b.classList.toggle('text-blue-600', b.dataset.mode === m);
      b.classList.toggle('border-b-2', b.dataset.mode === m);
      b.classList.toggle('border-blue-600', b.dataset.mode === m);
      b.classList.toggle('text-gray-600', b.dataset.mode !== m);
    });
    if(m === 'groups') displaySubtitle.textContent = 'グループ（1グループずつ表示）';
    if(m === 'order') displaySubtitle.textContent = '順番（1件ずつ表示）';
    if(m === 'roles') displaySubtitle.textContent = '役職（1件ずつ表示）';
    rebuildListCompact();

    // If no results exist for this mode -> show "未実行"
    if((counts[m] || 0) === 0){
      bulkView = false;
      revealed = false;
      // show a neutral "未実行" (exception to black initial state)
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280'; // gray-500
      displayItem.style.fontSize = '';
      displayItem.textContent = '未実行';
      // ensure subtitle/hint visible for modes with no data (but will be hidden when bulkView or fullscreen)
      if(!document.body.classList.contains('fullscreen-active')){
        displaySubtitle.style.display = ''; displayHint.style.display = '';
      } else {
        displaySubtitle.style.display = 'none'; displayHint.style.display = 'none';
      }
      updateControls();
      return;
    }

    // otherwise, keep initial black state until a display control is pressed
    revealed = false;
    bulkView = false;
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayItem.textContent = '';
    displayItem.style.color = '#FFFFFF';
    displayItem.style.fontSize = '';
    // restore subtitle/hint (unless fullscreen)
    if(!document.body.classList.contains('fullscreen-active')){
      displaySubtitle.style.display = ''; displayHint.style.display = '';
    } else {
      displaySubtitle.style.display = 'none'; displayHint.style.display = 'none';
    }
    updateControls();
  }
  modeBtns.forEach(b => b.addEventListener('click', ()=> setMode(b.dataset.mode)));

  function rebuildListCompact(){
    const listCompact = document.getElementById('list-compact');
    if(!listCompact) return;
    listCompact.innerHTML = '';
    if(mode === 'groups'){
      groupsList.forEach((g,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${g.label} (${g.members.length})`;
        el.addEventListener('click', () => { indices.groups = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(groupsList.length === 0) listCompact.textContent = '';
    } else if(mode === 'order'){
      orderList.forEach((o,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${o.name || JSON.stringify(o)}`;
        el.addEventListener('click', () => { indices.order = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(orderList.length === 0) listCompact.textContent = '';
    } else if(mode === 'roles'){
      rolesList.forEach((r,i) => {
        const el = document.createElement('div');
        el.className = 'p-2 bg-white rounded cursor-pointer hover:bg-gray-50';
        el.textContent = `${i+1}. ${r.name || ''} ${r.role ? '– ' + r.role : ''}`;
        el.addEventListener('click', () => { indices.roles = i; bulkView = false; revealCurrent(); });
        listCompact.appendChild(el);
      });
      if(rolesList.length === 0) listCompact.textContent = '';
    }
    counts.groups = groupsList.length; counts.order = orderList.length; counts.roles = rolesList.length;
  }

  // display control refs
  const btnReveal = document.getElementById('btn-reveal');
  const btnPrevItem = document.getElementById('btn-prev-item');
  const btnNextItem = document.getElementById('btn-next-item');
  const btnStepItem = document.getElementById('btn-step-item');

  function updateControls(){
    const len = counts[mode] || 0;
    const idx = indices[mode] || 0;
    if(btnPrevItem) btnPrevItem.disabled = !revealed || idx <= 0;
    if(btnNextItem) btnNextItem.disabled = !revealed || idx >= len - 1;
    if(btnStepItem) btnStepItem.disabled = revealed && idx >= len - 1;
  }

  function formatGroupForDisplay(g){
    const members = Array.isArray(g.members) ? g.members : [];
    const header = (g.label && g.label !== '') ? `${g.label}（${members.length}名）` : `（${members.length}名）`;
    const memberNames = members.map(m => (typeof m === 'string' ? m : (m.name || m.full_name || JSON.stringify(m)))).filter(Boolean).join(', ');
    return memberNames ? `${header}\n${memberNames}` : header;
  }

  function formatOrderForDisplay(o){
    if(!o) return '';
    if(typeof o === 'string') return o;
    if(o.name) return o.name;
    return JSON.stringify(o);
  }

  function formatRoleForDisplay(r){
    if(!r) return '';
    return (r.name || '') + (r.role ? ` — ${r.role}` : '');
  }

  function renderBulkList(){
    // render all items for current mode in a consistent font size; allow scroll via display-area
    let lines = [];
    if(mode === 'groups'){
      groupsList.forEach((g,i) => {
        const members = Array.isArray(g.members) ? g.members.map(m => (typeof m === 'string' ? m : (m.name || m.full_name || JSON.stringify(m)))).filter(Boolean).join(', ') : '';
        const header = `${i+1}. ${g.label}（${(g.members||[]).length}名）`;
        lines.push(members ? `${header}\n${members}` : header);
      });
    } else if(mode === 'order'){
      orderList.forEach((o,i) => {
        lines.push(`${i+1}. ${formatOrderForDisplay(o)}`);
      });
    } else if(mode === 'roles'){
      rolesList.forEach((r,i) => {
        lines.push(`${i+1}. ${formatRoleForDisplay(r)}`);
      });
    }
    // uniform font-size for bulk (clear inline font-size so CSS handles responsive sizing)
    displayArea.classList.remove('bg-black');
    displayArea.classList.add('bg-white');
    displayItem.style.color = '#111827'; // gray-900
    displayItem.style.fontSize = '';
    displayItem.textContent = lines.join('\n');
    // ensure inner alignment uses top-left for lists
    displayInner.style.alignItems = 'flex-start';
  }

  function updateDisplay(){
    const len = counts[mode] || 0;
    const idx = indices[mode] || 0;

    // If no results -> handled in setMode but keep fallback
    if(len === 0){
      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280';
      displayItem.style.fontSize = '';
      displayItem.textContent = '未実行';
      // ensure subtitle/hint visible (unless fullscreen)
      if(!document.body.classList.contains('fullscreen-active')){
        displaySubtitle.style.display = ''; displayHint.style.display = '';
      } else {
        displaySubtitle.style.display = 'none'; displayHint.style.display = 'none';
      }
      updateControls();
      return;
    }

    if(!revealed){
      // initial black state (no content shown)
      displayArea.classList.add('bg-black');
      displayArea.classList.remove('bg-white');
      displayInner.style.alignItems = 'center';
      displayItem.style.color = '#FFFFFF';
      displayItem.style.fontSize = '';
      displayItem.textContent = '';
      // ensure subtitle/hint visible (unless fullscreen)
      if(!document.body.classList.contains('fullscreen-active')){
        displaySubtitle.style.display = ''; displayHint.style.display = '';
      } else {
        displaySubtitle.style.display = 'none'; displayHint.style.display = 'none';
      }
      updateControls();
      return;
    }

    // revealed path
    if(bulkView){
      // hide explanatory subtitle/hint in bulk view
      if(displaySubtitle) displaySubtitle.style.display = 'none';
      if(displayHint) displayHint.style.display = 'none';
      renderBulkList();
    } else {
      // single-item view
      // restore subtitle/hint only if not fullscreen; otherwise keep hidden
      if(!document.body.classList.contains('fullscreen-active')){
        if(displaySubtitle) displaySubtitle.style.display = '';
        if(displayHint) displayHint.style.display = '';
      } else {
        if(displaySubtitle) displaySubtitle.style.display = 'none';
        if(displayHint) displayHint.style.display = 'none';
      }

      displayArea.classList.remove('bg-black');
      displayArea.classList.add('bg-white');
      displayInner.style.alignItems = 'center';
      displayItem.style.color = '#111827';
      displayItem.style.fontSize = '';

      if(mode === 'groups'){
        displayItem.textContent = formatGroupForDisplay(groupsList[idx] || {});
      } else if(mode === 'order'){
        const item = orderList[idx] || {};
        let namePart = formatOrderForDisplay(item);
        if(item && Array.isArray(item.members) && item.members.length > 0){
          const lines = [`${idx+1}. ${namePart}`, ''];
          item.members.forEach(m => lines.push(typeof m === 'string' ? m : (m.name || m.full_name || JSON.stringify(m))));
          displayItem.textContent = lines.join('\n');
        } else {
          displayItem.textContent = `${idx+1}. ${namePart}`;
        }
      } else if(mode === 'roles'){
        displayItem.textContent = formatRoleForDisplay(rolesList[idx] || {});
      }
    }

    updateControls();
  }

  function revealCurrent(asBulk){
    revealed = true;
    bulkView = !!asBulk;
    updateDisplay();
  }
  function hideAll(){
    revealed = false;
    bulkView = false;
    displayItem.textContent = '';
    displayArea.classList.add('bg-black');
    displayArea.classList.remove('bg-white');
    displayInner.style.alignItems = 'center';
    // restore subtitle/hint (unless fullscreen)
    if(!document.body.classList.contains('fullscreen-active')){
      if(displaySubtitle) displaySubtitle.style.display = '';
      if(displayHint) displayHint.style.display = '';
    } else {
      if(displaySubtitle) displaySubtitle.style.display = 'none';
      if(displayHint) displayHint.style.display = 'none';
    }
    updateControls();
  }

  // flash helper (イベント作成ページと同様の表示)
  function showFlash(text, ms){
    if(!flashMessageEl) return;
    flashMessageEl.textContent = text;
    flashMessageEl.classList.remove('hidden');
    flashMessageEl.style.opacity = '1';
    clearTimeout(flashMessageEl._timeout);
    flashMessageEl._timeout = setTimeout(() => {
      flashMessageEl.style.opacity = '0';
      setTimeout(()=> flashMessageEl.classList.add('hidden'), 200);
    }, ms || 1800);
  }

  if(btnReveal) btnReveal.addEventListener('click', () => {
    // no-op if already bulk-viewing
    if(bulkView) return;
    // hide subtitle/hint when revealing all
    if(displaySubtitle) displaySubtitle.style.display = 'none';
    if(displayHint) displayHint.style.display = 'none';
    revealCurrent(true);
  });
  if(btnHideResults) btnHideResults.addEventListener('click', () => {
    hideAll();
  });
  if(btnPrevItem) btnPrevItem.addEventListener('click', () => {
    if((counts[mode]||0) === 0) return;
    // hide subtitle/hint when navigating
    if(displaySubtitle) displaySubtitle.style.display = 'none';
    if(displayHint) displayHint.style.display = 'none';
    if(indices[mode] > 0){ indices[mode]--; revealCurrent(false); }
  });
  if(btnNextItem) btnNextItem.addEventListener('click', () => {
    if((counts[mode]||0) === 0) return;
    // hide subtitle/hint when navigating
    if(displaySubtitle) displaySubtitle.style.display = 'none';
    if(displayHint) displayHint.style.display = 'none';
    if(indices[mode] < (counts[mode]-1)){ indices[mode]++; revealCurrent(false); }
    // if now at last, flash with same wording/style as other pages
    if(indices[mode] === (counts[mode]-1)){
      showFlash('最後の結果です', 1800);
    }
  });
  if(btnStepItem) btnStepItem.addEventListener('click', () => {
    // when there are no items, show "未実行" even if the display area was black
    if((counts[mode]||0) === 0){
      revealed = true; bulkView = false;
      displayArea.classList.remove('bg-black'); displayArea.classList.add('bg-white');
      displayItem.style.color = '#6B7280'; displayItem.style.fontSize = '';
      displayItem.textContent = '未実行';
      // ensure subtitle/hint visible (unless fullscreen)
      if(!document.body.classList.contains('fullscreen-active')){
        if(displaySubtitle) displaySubtitle.style.display = '';
        if(displayHint) displayHint.style.display = '';
      } else {
        if(displaySubtitle) displaySubtitle.style.display = 'none';
        if(displayHint) displayHint.style.display = 'none';
      }
      updateControls();
      return;
    }
    // hide subtitle/hint when stepping
    if(displaySubtitle) displaySubtitle.style.display = 'none';
    if(displayHint) displayHint.style.display = 'none';
    if(!revealed){
      revealCurrent(false);
      // if only one item, flash as last
      if(counts[mode] === 1){
        showFlash('最後の結果です', 1800);
      }
    } else if(indices[mode] < (counts[mode]-1)){
      indices[mode]++; revealCurrent(false);
      if(indices[mode] === (counts[mode]-1)){
        showFlash('最後の結果です', 1800);
      }
    } else {
      // at end: reveal last and flash
      indices[mode] = Math.max(0, counts[mode]-1);
      revealCurrent(false);
      showFlash('最後の結果です', 1800);
    }
  });

  // fullscreen toggle (shared handler for both buttons)
  function toggleFullscreen(){
    document.body.classList.toggle('fullscreen-active');
    const active = document.body.classList.contains('fullscreen-active');
    if(btnToggleFullscreen) btnToggleFullscreen.textContent = active ? '全画面解除' : '全画面';
    if(btnMiniFullscreen) btnMiniFullscreen.textContent = active ? '✕' : '⛶';

    // when entering fullscreen, hide subtitle/hint and ensure title visible
    if(active){
      if(displaySubtitle) displaySubtitle.style.display = 'none';
      if(displayHint) displayHint.style.display = 'none';
      if(eventTitleWrap) eventTitleWrap.style.display = '';
    } else {
      // restore subtitle/hint to default visible state if not in revealed/empty state
      if(!revealed){
        if(displaySubtitle) displaySubtitle.style.display = '';
        if(displayHint) displayHint.style.display = '';
      } else {
        // revealed true: keep subtitle hidden unless not desired (single-item and not fullscreen)
        if(!document.body.classList.contains('fullscreen-active')){
          if(displaySubtitle) displaySubtitle.style.display = '';
          if(displayHint) displayHint.style.display = '';
        }
      }
    }
  }
  if(btnToggleFullscreen) btnToggleFullscreen.addEventListener('click', toggleFullscreen);
  if(btnMiniFullscreen) btnMiniFullscreen.addEventListener('click', toggleFullscreen);

  // style settings toggle (click toggles show/hide like 統計情報を表示)
  if(btnToggleStyleSettings && styleSettingsDiv){
    btnToggleStyleSettings.addEventListener('click', (e) => {
      if(e) e.preventDefault();
      styleSettingsDiv.classList.toggle('hidden');
      const expanded = !styleSettingsDiv.classList.contains('hidden');
      try { btnToggleStyleSettings.setAttribute('aria-expanded', expanded.toString()); } catch(err){}
    });
  }

  // init (do not reveal anything on load)
  setMode('groups');
  rebuildListCompact();
  updateDisplay();

  // --- helpers reused from above ---
  function parseHistoryToGroups(raw){
    if(!raw) return [];
    let lines = [];
    if(Array.isArray(raw)) {
      lines = raw.map(r => (typeof r === 'string' ? r : (r.name || JSON.stringify(r))));
    } else if(typeof raw === 'string'){
      lines = raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    } else {
      return [];
    }
    const groupsMap = {};
    for(const line of lines){
      const name = line.split('#')[0].trim();
      const m = line.match(/#\d+([A-Z])$/);
      const id = m ? m[1] : null;
      const key = id || 'A';
      if(!groupsMap[key]) groupsMap[key]=[];
      groupsMap[key].push(name);
    }
    const keys = Object.keys(groupsMap).sort();
    return keys.map(k => ({ label: `グループ ${k}`, members: groupsMap[k] }));
  }

  // --- receive updates from authoring window (BroadcastChannel) and fallback via storage ---
  try {
    if (typeof BroadcastChannel !== 'undefined') {
      const bc = new BroadcastChannel('shuffly_channel');
      bc.onmessage = (ev) => {
        try {
          const data = ev.data;
          if(!data) return;
          if(data.type === 'init' || data.type === 'update'){
            const p = data.payload || {};
            payload = {
              members_json: safeParse(p.members_json) || p.members_json || payload.members_json,
              results_json: safeParse(p.results_json) || p.results_json || payload.results_json,
              order_json: safeParse(p.order_json) || p.order_json || payload.order_json,
              settings_json: safeParse(p.settings_json) || p.settings_json || payload.settings_json,
              history_json: safeParse(p.history_json) || p.history_json || payload.history_json,
              title: p.title || payload.title
            };

            if(eventTitleEl){
              if(payload.title && payload.title.trim() !== ''){
                eventTitleEl.textContent = payload.title;
                eventTitleEl.classList.remove('hidden');
              } else {
                eventTitleEl.textContent = '';
                eventTitleEl.classList.add('hidden');
              }
            }

            const newGroups = normalizeGroups(payload.results_json);
            groupsList.length = 0; Array.prototype.push.apply(groupsList, newGroups);

            const newOrder = (Array.isArray(payload.order_json) ? payload.order_json.map(it => (typeof it === 'string' ? {name:it} : it)) : []);
            orderList.length = 0; Array.prototype.push.apply(orderList, newOrder);

            const s = payload.settings_json || (payload.settingsJson || {});
            const newRoles = (s && Array.isArray(s.role_assignments)) ? s.role_assignments.map(r=>({name:r.name, role:r.role})) : (s && s.roles && typeof s.roles === 'object' ? Object.keys(s.roles).map(k=>({name:k, role:s.roles[k]})) : []);
            rolesList.length = 0; Array.prototype.push.apply(rolesList, newRoles);

            const parsedHistory = Array.isArray(payload.history_json) ? payload.history_json.slice() : (typeof payload.history_json === 'string' ? (safeParse(payload.history_json) || []) : []);
            history = parsedHistory.length ? parsedHistory : history;
            historyIdx = history.length > 0 ? history.length - 1 : -1;

            if(indices.groups >= groupsList.length) indices.groups = Math.max(0, groupsList.length-1);
            if(indices.order >= orderList.length) indices.order = Math.max(0, orderList.length-1);
            if(indices.roles >= rolesList.length) indices.roles = Math.max(0, rolesList.length-1);

            rebuildListCompact();
            updateSnapshotUI();
            updateDisplay();
          }
        } catch(err){
          console.warn('shuffly_channel handler error', err);
        }
      };
    }
  } catch(e){
    console.warn('BroadcastChannel not available', e);
  }

  // storage fallback
  window.addEventListener('storage', function(e){
    if(!e || !e.key) return;
    if(e.key === 'presentation_shuffly_event'){
      try {
        const raw = e.newValue;
        if(!raw) return;
        const p = safeParse(raw) || JSON.parse(raw);
        payload = {
          members_json: safeParse(p.members_json) || p.members_json || payload.members_json,
          results_json: safeParse(p.results_json) || p.results_json || payload.results_json,
          order_json: safeParse(p.order_json) || p.order_json || payload.order_json,
          settings_json: safeParse(p.settings_json) || p.settings_json || payload.settings_json,
          history_json: safeParse(p.history_json) || p.history_json || payload.history_json,
          title: p.title || payload.title
        };
        if(eventTitleEl){
          if(payload.title && payload.title.trim() !== ''){
            eventTitleEl.textContent = payload.title;
            eventTitleEl.classList.remove('hidden');
          } else {
            eventTitleEl.textContent = '';
            eventTitleEl.classList.add('hidden');
          }
        }
        const newGroups = normalizeGroups(payload.results_json);
        groupsList.length = 0; Array.prototype.push.apply(groupsList, newGroups);
        const newOrder = (Array.isArray(payload.order_json) ? payload.order_json.map(it => (typeof it === 'string' ? {name:it} : it)) : []);
        orderList.length = 0; Array.prototype.push.apply(orderList, newOrder);
        const s = payload.settings_json || (payload.settingsJson || {});
        const newRoles = (s && Array.isArray(s.role_assignments)) ? s.role_assignments.map(r=>({name:r.name, role:r.role})) : (s && s.roles && typeof s.roles === 'object' ? Object.keys(s.roles).map(k=>({name:k, role:s.roles[k]})) : []);
        rolesList.length = 0; Array.prototype.push.apply(rolesList, newRoles);
        const parsedHistory = Array.isArray(payload.history_json) ? payload.history_json.slice() : (typeof payload.history_json === 'string' ? (safeParse(payload.history_json) || []) : []);
        history = parsedHistory.length ? parsedHistory : history;
        historyIdx = history.length > 0 ? history.length - 1 : -1;
        if(indices.groups >= groupsList.length) indices.groups = Math.max(0, groupsList.length-1);
        if(indices.order >= orderList.length) indices.order = Math.max(0, orderList.length-1);
        if(indices.roles >= rolesList.length) indices.roles = Math.max(0, rolesList.length-1);
        rebuildListCompact();
        updateSnapshotUI();
        updateDisplay();
      } catch(err){ /* ignore parse errors */ }
    }
  });

  // keyboard (modified: Escape only toggles fullscreen; removed navigation to settings)
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') {
      if(document.body.classList.contains('fullscreen-active')){
        toggleFullscreen();
      }
      return;
    }
    if(e.key === 'ArrowLeft') document.getElementById('btn-prev-item').click();
    if(e.key === 'ArrowRight') document.getElementById('btn-next-item').click();
    if(e.key === ' '){ e.preventDefault(); revealed ? hideAll() : revealCurrent(false); }
  });

  // style selector persistence (including new 演出 and 効果音 options)
  try {
    const radios = document.querySelectorAll('input[name="presentationStyle"]');
    const stored = localStorage.getItem('presentation_style');
    if(stored){
      radios.forEach(r => { if(r.value === stored) r.checked = true; });
    } else {
      // ensure default is 'simple'
      radios.forEach(r => { if(r.value === 'simple') r.checked = true; });
    }
    radios.forEach(r => r.addEventListener('change', (e) => {
      try { localStorage.setItem('presentation_style', e.target.value); } catch(e){}
    }));

    const perfRadios = document.querySelectorAll('input[name="presentationPerformance"]');
    const perfStored = localStorage.getItem('presentation_performance');
    if(perfStored){
      perfRadios.forEach(r => { if(r.value === perfStored) r.checked = true; });
    }
    perfRadios.forEach(r => r.addEventListener('change', (e) => {
      try { localStorage.setItem('presentation_performance', e.target.value); } catch(e){}
    }));

    const soundRadios = document.querySelectorAll('input[name="presentationSound"]');
    const soundStored = localStorage.getItem('presentation_sound');
    if(soundStored){
      soundRadios.forEach(r => { if(r.value === soundStored) r.checked = true; });
    }
    soundRadios.forEach(r => r.addEventListener('change', (e) => {
      try { localStorage.setItem('presentation_sound', e.target.value); } catch(e){}
    }));
  } catch(e){}

})();
</script>