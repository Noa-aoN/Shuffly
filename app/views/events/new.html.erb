<div class="max-w-6xl mx-auto px-6 pt-2 pb-10">
  <h1 class="text-3xl font-bold mb-8"><%= @event.title.presence || "イベント作成" %></h1>

  <div class="flex flex-col gap-6">

    <!-- ① メンバーを追加 -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">1</div>
        <h2 class="text-lg font-semibold">メンバーを入力</h2>
      </div>

      <label class="block text-sm font-medium mb-2">メンバー名リスト（改行またはカンマ区切り）</label>
      <textarea id="membersInput" rows="8" class="w-full border rounded-md px-3 py-2 mb-3" placeholder="例：メンバー1, メンバー2, ..."><%= begin
        members = @event.members_json.present? ? JSON.parse(@event.members_json) : []
        members.map do |m|
          if m.is_a?(Hash)
            name = m["name"]
            hist = m["history"]&.join("") || ""
            "#{name}#{hist}"
          else
            m
          end
        end.join("\n")
      rescue JSON::ParserError
        ""
      end %></textarea>

      <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
        <a href="#" id="btn-trigger-import" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">メンバーリストから入力</a>
        <input id="importFile" type="file" accept=".txt,.csv" class="hidden">
        <a href="#" id="btn-paste-clipboard" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">クリップボードから入力</a>
        <a href="#" id="btn-clear-history" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">履歴をクリア</a>
      </div>
    </div>

    <!-- ② 設定を選択（タブ切替: グループ / 順番 / 役割） -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">2</div>
        <h2 class="text-lg font-semibold">設定 / 実行</h2>
      </div>

      <!-- タブボタン（カード名の下・中央配置・下線バー風） -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-settings-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">グループ設定</button>
        <button id="tab-settings-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">順番設定</button>
        <button id="tab-settings-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">役割設定</button>
      </div>

      <!-- グループパネル -->
      <div id="panel-settings-groups" class="settings-panel">
        <div class="mb-4">
          <label class="block font-medium mb-1">グループ分けオプション</label>
          <div class="flex flex-col gap-3 mb-2">
            <div>
              <label class="text-xs text-gray-600">グループ数</label>
              <input id="groupCount" type="number" min="1" max="26" value="<%= @event.group_count.presence || 3 %>" class="mt-1 w-full border rounded px-2 py-1">
            </div>
            <div>
              <label class="text-xs text-gray-600">グループ名（任意・改行/カンマ区切り）</label>
              <textarea id="customGroupNames" rows="3" class="w-full border rounded px-2 py-1" placeholder="例：グループA, グループB, ..."></textarea>
              <p class="text-xs text-gray-500 mt-1">グループ名を入力すると、その数が優先してグループ数に反映されます。</p>
            </div>
          </div>

          <div>
            <label class="text-xs text-gray-600">固定メンバー（任意・改行/カンマ区切り）</label>
            <textarea id="fixedMembersInput" rows="2" class="w-full border rounded px-2 py-1" placeholder="例：メンバー3, メンバー5, ..."></textarea>
            <p class="text-xs text-gray-500 mt-1">固定メンバーはグループ分け実行時に可能な限り指定グループに残します（自動振り分けとの兼ね合いにより完全固定にならない場合があります）。</p>
          </div>

          <div id="groupSizeHint" class="text-xs text-gray-500 mt-2"></div>
        </div>
      </div>

      <!-- 順番パネル -->
      <div id="panel-settings-order" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">順番決めオプション</label>

          <div class="mb-2">
            <label class="text-xs text-gray-600">特定メンバーの順番を固定（任意・改行/カンマ区切り）</label>
            <textarea id="fixedOrderInput" rows="3" class="w-full border rounded px-2 py-1" placeholder="例：1:メンバー3, 5:メンバー1, ..."></textarea>
            <p class="text-xs text-gray-500 mt-1">「番号:メンバー名」を入力してください。順番決め実行時にその番号に対応するメンバーが固定され、残りのメンバーはランダムに割り当てられます。</p>
          </div>

          <p class="text-xs text-gray-500 mt-2">固定を使わない場合は空欄のまま「順番決め実行」を押すと全員の順番がランダムに決まります。</p>
        </div>
      </div>

      <!-- 役割パネル（オプションは除去。役割は常にランダムかつ一意に割り当てられます） -->
      <div id="panel-settings-roles" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">役割決めオプション</label>
          <textarea id="rolesInput" rows="2" class="w-full border rounded px-2 py-1" placeholder="例：司会, 書記, ..."><%= @event.setting_json["roles"] rescue "" %></textarea>

          <p class="text-xs text-gray-500 mt-2">複数の役割をカンマ区切りで入力してください。役割の割り当ては常にランダムに行われ、各役割は可能な限り異なるメンバーに一意に割り当てられます。</p>
        </div>
      </div>

      <!-- ボタン群（パネル毎に表示） -->
      <!-- グループ用アクション -->
      <div id="settings-action-groups" class="mt-4">
        <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: 'グループ分け実行',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
          <%= render 'shared/button',
                f: nil,
                button_text: '前のグループへ',
                id: nil,
                path: '#',
                variant: 'secondary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
          <%= render 'shared/button',
                f: nil,
                button_text: '後ろのグループへ',
                id: nil,
                path: '#',
                variant: 'secondary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        </div>
      </div>

      <!-- 順番用アクション -->
      <div id="settings-action-order" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: '順番決め実行',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>

      <!-- 役割用アクション -->
      <div id="settings-action-roles" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: '役割決め実行',
                id: nil,
                path: '#',
                variant: 'secondary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        </div>
      </div>
    </div>

    <!-- ③ 結果 -->
    <div id="resultsCard" class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start justify-between mb-4">
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">3</div>
          <h2 class="text-lg font-semibold">結果を表示</h2>
        </div>
      </div>

      <!-- タブボタン（カード名の下・中央配置・下線バー風） -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">グループ表示</button>
        <button id="tab-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">順番表示</button>
        <button id="tab-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">役割表示</button>
      </div>

      <!-- グループ表示＋統計（デフォルト表示） -->
      <div id="panel-groups" class="result-panel">
        <h3 class="font-medium mb-2">グループ表示</h3>

        <div class="mb-2">
          <label class="inline-flex items-center gap-1 mb-2">
            <input type="checkbox" id="showGroupLabel" checked class="rounded border-gray-300">
            <span class="text-sm ml-2">グループ名表示</span>
          </label>
          <div class="mt-2">
            <label class="text-sm mr-2">メンバーの区切り方:</label>
            <select id="separatorSelect" class="border rounded-md px-2 py-1 mt-1">
              <option value=" ">スペース</option>
              <option value=",">カンマ</option>
              <option value="  ">ダブルスペース</option>
              <option value="\t">タブ</option>
            </select>
          </div>
        </div>

        <!-- 結果表示フォーム色を薄いグレー系に変更 -->
        <!-- 初期は空。グループ分け実行ボタン押下後に初回表示される -->
        <textarea id="groupOutput" rows="8" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full mb-4 text-lg"></textarea>

        <h3 class="font-medium mb-2">統計情報</h3>
        <textarea id="statsOutput" rows="6" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-sm"></textarea>

        <!-- クリップボードコピー（リンクスタイル） -->
        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-groupoutput" class="text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>

      <!-- 順番表示パネル -->
      <div id="panel-order" class="result-panel hidden">
        <h3 class="font-medium mb-2">順番表示</h3>
        <textarea id="orderOutput" rows="10" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-orderoutput" class="text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>

      <!-- 役割表示パネル -->
      <div id="panel-roles" class="result-panel hidden">
        <h3 class="font-medium mb-2">役割表示</h3>
        <textarea id="rolesOutput" rows="8" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-rolesoutput" class="text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>
    </div>

    <!-- ④ 出力 -->
    <div class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">4</div>
        <h2 class="text-lg font-semibold">共有 / 出力 / 保存</h2>
      </div>

      <label class="block text-sm font-medium mb-2">イベントタイトル（任意）</label>
      <!-- イベントタイトルフォームの色を白系に戻す -->
      <input id="shareEventTitle" type="text" value="<%= @event.title %>" class="w-full border rounded px-3 py-2 mb-3 bg-white" placeholder="例：〇〇イベント">

      <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
        <%= render 'shared/button',
              f: nil,
              button_text: '画面共有表示',
              id: 'btn-toggle-presentation',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'テキスト出力',
              id: 'btn-export-results',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'イベント保存',
              id: 'btn-save-results',
              path: '#',
              variant: 'primary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
      </div>

      <p class="text-xs text-gray-500">イベント保存にはログインが必要です。</p>

      <!-- hidden 保存フォーム（submit は saveResults() が制御） -->
      <%= form_with(model: @event, local: true, html: { id: 'saveForm', style: 'display:none' }) do |f| %>
        <%= f.hidden_field :members_json, id: 'membersJsonInput' %>
        <%= f.hidden_field :member_results_json, id: 'resultsJsonInput' %>
        <%= f.hidden_field :member_order_json, id: 'orderJsonInput' %>
        <%= f.hidden_field :setting_json, id: 'settingsJsonInput' %>
        <%= f.hidden_field :history_json, id: 'historyJsonInput' %>
        <%= f.hidden_field :title, value: @event.title, name: 'event[title]', id: 'hiddenEventTitle' %>
      <% end %>
    </div>

  </div>

  <div id="toast" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-black text-white px-4 py-2 rounded opacity-0 transition-opacity"></div>
</div>

<script>
let shufflyHistory = [], currentHistoryIndex = -1;
const IS_SIGNED_IN = <%= user_signed_in? ? 'true' : 'false' %>;

// --- helper functions (existing) ---
function clampGroupCount(v){
  return Math.min(Math.max(parseInt(v) || 1, 1), 26);
}
function parseEntry(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  return {name, history: hist};
}
function getCurrentRound(entries){
  let max=0;
  for(const e of entries) for(const h of e.history) {
    const m = h.match(/^#(\d+)/);
    if(m) max=Math.max(max, parseInt(m[1]));
  }
  return max+1;
}
function getCoOccurrenceMap(entries, ignoreLast=true){
  const map={}, histories={};
  for(const e of entries) histories[e.name]=ignoreLast?e.history.slice(0,-1):e.history;
  for(const e of entries) map[e.name]={};
  for(const a of entries){
    for(const b of entries){
      if(a.name===b.name) continue;
      const overlap=histories[a.name].filter(h=>histories[b.name].includes(h));
      map[a.name][b.name]=overlap.length;
    }
  }
  return map;
}

// 共通: グループID(A,B,...)と表示名の決定
function buildGroupIdsAndNames(){
  const groupCountInputEl = document.getElementById('groupCount');
  const inputGroupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  const customNamesEl = document.getElementById('customGroupNames');
  const customNames = (customNamesEl ? customNamesEl.value : "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);

  let groupCount;
  let ids = [];
  let displayNames = [];

  if(customNames.length > 0){
    groupCount = Math.min(customNames.length, 26);
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = customNames.slice(0, groupCount);
  } else {
    groupCount = inputGroupCount;
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = ids.slice();
  }

  const idToName = {};
  ids.forEach((id, idx) => idToName[id] = displayNames[idx] || id);
  return { ids, displayNames, idToName, groupCount };
}

function assignGroups(){
  const input=document.getElementById('membersInput');
  let raw=input.value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  let entries=raw.map(parseEntry);
  const round=getCurrentRound(entries);

  const { ids: groupIds, idToName, groupCount } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  const coMap=getCoOccurrenceMap(entries);

  // 固定メンバーを考慮（簡易実装: 固定メンバーは先にグループの先頭に配置）
  const fixedRaw = (document.getElementById('fixedMembersInput').value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedSet = new Set(fixedRaw);
  const fixedEntries = entries.filter(e=>fixedSet.has(e.name));
  const otherEntries = entries.filter(e=>!fixedSet.has(e.name));

  // まず固定を一人ずつ空のグループに割り当て（存在すれば）
  for(const p of fixedEntries){
    let emptyGroup = groupIds.find(g=>groups[g].length===0);
    if(emptyGroup){ groups[emptyGroup].push(p); }
    else {
      const minSize=Math.min(...groupIds.map(g=>groups[g].length));
      const candidates=groupIds.filter(g=>groups[g].length===minSize);
      groups[candidates[0]].push(p);
    }
  }

  // ランダム化オプションは順番パネルから削除されたため、ここでは常にランダム配置せずに最小被り優先で割当
  for(const p of otherEntries){
    let emptyGroup=groupIds.find(g=>groups[g].length===0);
    if(emptyGroup){ groups[emptyGroup].push(p); continue; }

    const minSize=Math.min(...groupIds.map(g=>groups[g].length));
    const candidates=groupIds.filter(g=>groups[g].length===minSize);
    let minMK=Infinity, selected=candidates[0];
    for(const g of candidates){
      const mk=groups[g].reduce((acc,q)=>acc+(coMap[p.name][q.name]||0),0);
      if(mk<minMK){minMK=mk; selected=g;}
    }
    groups[selected].push(p);
  }

  // グループ内での役割付与（入力があれば、循環割当てで付与）
  const rolesForGroups = document.getElementById('rolesInput').value.split(',').map(r=>r.trim()).filter(Boolean);
  if(rolesForGroups.length>0){
    for(const g of groupIds){
      const members=groups[g];
      members.forEach((m,i)=>m.role=rolesForGroups[i%rolesForGroups.length]);
    }
  }

  const updated=groupIds.flatMap(g=>groups[g].map(e=>`${e.name}${e.history.join('')}#${round}${g}`));
  input.value=updated.join("\n");

  try{
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: groups, group_names: buildGroupIdsAndNames().idToName });
    document.getElementById('settingsJsonInput').value = JSON.stringify({
      roles: document.getElementById('rolesInput').value,
      group_count: groupCount,
      custom_group_names: (document.getElementById('customGroupNames').value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean)
    });
  }catch(e){
    console.warn("JSON シリアライズ失敗:", e);
  }

  updateParticipantCount(); showGroups(); showStats(); pushToHistory();
  // SPA behavior: reflect results immediately without reload
  switchResultTab('groups');
}

function assignOrder(){
  const raw=document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  let members=raw.map(s=>s.split('#')[0].trim());
  if(members.length === 0){
    document.getElementById('orderOutput').value = "";
    if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = "[]";
    showToast("参加者がいません");
    return;
  }

  // 固定順のパース（例: "1: 田中 太郎" を1ベースで解釈）
  const fixedRaw = (document.getElementById('fixedOrderInput')?.value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedMap = {}; // pos (1-based) -> name
  const invalids = [];
  for(const line of fixedRaw){
    if(!line) continue;
    const m = line.match(/^(\d+)\s*[:=]\s*(.+)$/) || line.match(/^(\d+)\s+(.+)$/);
    if(m){
      const pos = parseInt(m[1],10);
      const name = m[2].trim();
      if(pos >= 1 && pos <= members.length){
        fixedMap[pos] = name;
      } else {
        invalids.push(line);
      }
    } else {
      invalids.push(line);
    }
  }

  // 検証: 固定指定の名前が参加者に存在するか確認
  const namesSet = new Set(members);
  const assignedFixedNames = new Set();
  const invalidNameEntries = [];
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    const name = fixedMap[pos];
    if(!namesSet.has(name)){
      invalidNameEntries.push(`${pos}: ${name}`);
      delete fixedMap[pos];
    } else {
      assignedFixedNames.add(name);
    }
  }

  if(invalids.length>0 || invalidNameEntries.length>0){
    const msgs = [];
    if(invalids.length>0) msgs.push("固定指定の書式が不正な行があります");
    if(invalidNameEntries.length>0) msgs.push("参加者に存在しない名前の固定指定があります");
    showToast(msgs.join('、') + "（無視されます）");
  }

  // プールを作成してシャッフル
  const pool = members.filter(m=>!assignedFixedNames.has(m));
  for(let i=pool.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [pool[i], pool[j]]=[pool[j], pool[i]];
  }

  // 結果配列を作る（null で初期化）
  const result = Array(members.length).fill(null);

  // 固定を反映（posは1ベース）
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    result[pos-1] = fixedMap[pos];
  }

  // 残りスロットをプールで埋める
  let poolIdx = 0;
  for(let i=0;i<result.length;i++){
    if(result[i] === null){
      result[i] = pool[poolIdx++] || "";
    }
  }

  // 表示と保存
  const lines = result.map((name, idx) => `${idx+1}. ${name}`);
  document.getElementById('orderOutput').value = lines.join("\n");

  const orderJson = result.map((name, idx) => ({ name, order: idx+1 }));
  if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = JSON.stringify(orderJson);

  showToast("順番を割り当てました");
  switchResultTab('order');
}

function assignRoles(){
  const raw=document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  let members=raw.map(s=>s.split('#')[0].trim());
  if(members.length===0){ showToast("参加者がいません"); return; }

  const roles = document.getElementById('rolesInput').value.split(',').map(r=>r.trim()).filter(Boolean);
  if(roles.length===0){ showToast("役割が未入力です"); return; }

  // 常にランダムかつ一意に割り当てる（役割数 <= メンバー数 の場合は全て一意）
  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]]=[arr[j], arr[i]];
    }
  }

  const pool = members.slice();
  shuffleArray(pool);

  const assignments = [];
  // 各役割を一意に割り当てる（役割がメンバー数を上回る場合はトランケート）
  for(let i=0;i<roles.length && i<pool.length;i++){
    assignments.push({ name: pool[i], role: roles[i] });
  }
  // 残りメンバーはrole=null
  const assignedNames = new Set(assignments.map(a=>a.name));
  for(const m of members){
    if(!assignedNames.has(m)) assignments.push({ name: m, role: null });
  }

  // 表示: 役割つき → 役割なし の順で出す
  const displayLines = assignments.map(a => a.role ? `${a.name}: ${a.role}` : `${a.name}: `);
  document.getElementById('rolesOutput').value = displayLines.join("\n");

  // persist role_assignments in settingsJsonInput
  try {
    const settingsField = document.getElementById('settingsJsonInput');
    let settings = {};
    if(settingsField && settingsField.value) {
      try { settings = JSON.parse(settingsField.value); } catch(e){ settings = {}; }
    }
    settings.role_assignments = assignments.map(a => ({ name: a.name, role: a.role }));
    if(settingsField) settingsField.value = JSON.stringify(settings);
  } catch(e){
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value = JSON.stringify({ role_assignments: assignments.map(a=>({ name:a.name, role: a.role })) });
  }

  showToast("役割を割り当てました");
  // SPA reflect
  switchResultTab('roles');
}

function showGroups(){
  const raw=document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const entries=raw.map(parseEntry);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)) {
      let empty = groupIds.find(g=>groups[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groups[g].length));
        id = groupIds.find(g=>groups[g].length===minSize);
      }
    }
    groups[id].push(e.name);
  }

  const sep=document.getElementById('separatorSelect').value==='\\t'?'\t':document.getElementById('separatorSelect').value;
  const showLabel=document.getElementById('showGroupLabel').checked;
  let display='';
  for(const id of groupIds){
    const members=groups[id];
    const label = idToName[id] || id;
    if(showLabel) display+=`${label}（${members.length}人）：\n`;
    display+=members.join(sep)+'\n\n';
  }
  document.getElementById('groupOutput').value=display.trim();
}

function showStats(){
  const raw=document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const entries=raw.map(parseEntry);
  const coMap=getCoOccurrenceMap(entries,true);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groupMap=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)){
      let empty = groupIds.find(g=>groupMap[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groupMap[g].length));
        id = groupIds.find(g=>groupMap[g].length===minSize);
      }
    }
    groupMap[id].push(e.name);
  }

  const lines=[];
  for(const id of groupIds){
    const members=groupMap[id];
    let total=0;
    for(const m of members){
      const mk=members.reduce((sum,other)=>sum+(m!==other?(coMap[m][other]||0):0),0);
      lines.push(`${m}：被り数＝${mk}`);
      total+=mk;
    }
    lines.push(`${idToName[id] ? `グループ ${idToName[id]}` : `グループ ${id}`}（被り平均値＝${members.length? (total/members.length).toFixed(2):0}）`);
    lines.push('');
  }
  document.getElementById('statsOutput').value=lines.join("\n");
}

function updateParticipantCount(){
  const count=document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean).length;
  const span=document.getElementById('groupSizeHint');
  const { groupCount } = buildGroupIdsAndNames();
  if(!groupCount||count===0){ if(span) span.textContent=''; return;}
  const min=Math.floor(count/groupCount), max=Math.ceil(count/groupCount);
  if(span) span.textContent=min===max?`（1グループあたり${min}人）`:`（1グループあたり${min}〜${max}人）`;
}

function copyGroupOutput(){ navigator.clipboard.writeText(document.getElementById('groupOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyOrderOutput(){ navigator.clipboard.writeText(document.getElementById('orderOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyRolesOutput(){ navigator.clipboard.writeText(document.getElementById('rolesOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }

function showToast(msg){
  const toast=document.getElementById('toast');
  toast.textContent=msg;
  toast.classList.remove("opacity-0");
  setTimeout(()=>toast.classList.add("opacity-0"),1200);
}

function pushToHistory(){
  const text=document.getElementById('membersInput').value;
  if(currentHistoryIndex>=0 && shufflyHistory[currentHistoryIndex]===text) return;
  shufflyHistory = shufflyHistory.slice(0,currentHistoryIndex+1);
  shufflyHistory.push(text);
  currentHistoryIndex++;
  const histField = document.getElementById('historyJsonInput');
  if(histField) histField.value=JSON.stringify(shufflyHistory);
}

function undoHistory(){
  if(currentHistoryIndex>0){
    currentHistoryIndex--;
    document.getElementById('membersInput').value=shufflyHistory[currentHistoryIndex];
    updateParticipantCount(); /* do not auto-show groups/stats until assignGroups() */ showToast("1ステップ戻しました");
  } else showToast("これ以上戻れません");
}

function redoHistory(){
  if(currentHistoryIndex<shufflyHistory.length-1){
    currentHistoryIndex++;
    document.getElementById('membersInput').value=shufflyHistory[currentHistoryIndex];
    updateParticipantCount(); /* do not auto-show groups/stats until assignGroups() */ showToast("1ステップ進めました");
  } else showToast("これ以上進めません");
}

// 結果タブ切替
function switchResultTab(name){
  document.querySelectorAll('.result-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-groups, #tab-order, #tab-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-groups').classList.remove('hidden'); const el=document.getElementById('tab-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-order').classList.remove('hidden'); const el=document.getElementById('tab-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-roles').classList.remove('hidden'); const el=document.getElementById('tab-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
}

// 設定タブ切替（新規）
function switchSettingsTab(name){
  document.querySelectorAll('.settings-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-settings-groups, #tab-settings-order, #tab-settings-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-settings-groups').classList.remove('hidden'); const el=document.getElementById('tab-settings-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-settings-order').classList.remove('hidden'); const el=document.getElementById('tab-settings-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-settings-roles').classList.remove('hidden'); const el=document.getElementById('tab-settings-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }

  const gAct = document.getElementById('settings-action-groups');
  const oAct = document.getElementById('settings-action-order');
  const rAct = document.getElementById('settings-action-roles');
  if(gAct) gAct.classList.add('hidden');
  if(oAct) oAct.classList.add('hidden');
  if(rAct) rAct.classList.add('hidden');
  if(name==='groups' && gAct) gAct.classList.remove('hidden');
  if(name==='order' && oAct) oAct.classList.remove('hidden');
  if(name==='roles' && rAct) rAct.classList.remove('hidden');
}

// インポート補助
function triggerImport(){ const f = document.getElementById('importFile'); if(f) f.click(); }
function handleImportFile(e){
  const file = e.target.files ? e.target.files[0] : null;
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const text = ev.target.result;
    const cur = document.getElementById('membersInput').value.trim();
    const merged = (cur?cur + "\n":"") + text.replace(/\r/g,'').trim();
    document.getElementById('membersInput').value = merged;
    updateParticipantCount(); pushToHistory();
    showToast("ファイルをインポートしました");
    // do not auto-show groups/stats — user must press グループ分け実行
  };
  reader.readAsText(file, 'utf-8');
}
function pasteFromClipboard(){
  navigator.clipboard.readText().then(txt=>{
    const cur = document.getElementById('membersInput').value.trim();
    const merged = (cur?cur + "\n":"") + txt.replace(/\r/g,'').trim();
    document.getElementById('membersInput').value = merged;
    updateParticipantCount(); pushToHistory();
    showToast("クリップボードから貼り付けました");
    // do not auto-show groups/stats
  }).catch(()=>showToast("クリップボードにアクセスできません"));
}

// 履歴クリア（メンバー名の「#」以降を一括削除）
function clearMemberHistories(){
  if(!document.getElementById('membersInput')) return;
  const confirmed = window.confirm("メンバー名リストに含まれる全メンバーの履歴（「#」以降）を一括で削除します。よろしいですか？");
  if(!confirmed) return;

  const cur = document.getElementById('membersInput').value || "";
  // 分割して各エントリの「#」以降を削除し、空でないものだけ残す（出力は改行区切り）
  const cleaned = cur.split(/[\r\n,]+/).map(s=>s.split('#')[0].trim()).filter(Boolean);
  document.getElementById('membersInput').value = cleaned.join("\n");
  updateParticipantCount();
  pushToHistory();
  showToast("履歴をクリアしました");
}

function togglePresentationMode(){
  try{
    const payload = {
      members_json: (()=>{ try { return JSON.parse(document.getElementById('membersJsonInput')?.value || '[]'); } catch(e){ return document.getElementById('membersInput')?.value || ""; } })(),
      results_json: (()=>{ try { return JSON.parse(document.getElementById('resultsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('resultsJsonInput')?.value || ""; } })(),
      order_json: (()=>{ try { return JSON.parse(document.getElementById('orderJsonInput')?.value || '[]'); } catch(e){ return document.getElementById('orderOutput')?.value || ""; } })(),
      settings_json: (()=>{ try { return JSON.parse(document.getElementById('settingsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('settingsJsonInput')?.value || ""; } })(),
      history_json: document.getElementById('historyJsonInput')?.value || "",
      title: document.getElementById('shareEventTitle')?.value || document.title || ''
    };
    localStorage.setItem('presentation_shuffly_event', JSON.stringify(payload));
  }catch(e){
    console.warn('presentation payload store failed', e);
  }

  const presentationPath = '/events/show';
  const w = window.open(presentationPath, '_blank', 'noopener');
  if(!w) showToast("ポップアップがブロックされました。ポップアップを許可してください");
}

function exportResults(){
  const groups = document.getElementById('groupOutput').value;
  const order = document.getElementById('orderOutput').value;
  const roles = document.getElementById('rolesOutput').value;
  const blob = new Blob([`グループ:\n${groups}\n\n順番:\n${order}\n\n役割:\n${roles}`], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = (document.getElementById('shareEventTitle').value || 'shuffly_result') + '.txt';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast("結果を出力しました");
}

function saveResults(){
  try{
    const membersRaw = document.getElementById('membersInput').value.trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    const entries = membersRaw.map(m=> parseEntry(m) );
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}

  if(!document.getElementById('resultsJsonInput').value){
    try { document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: {}, group_names: {} }); } catch(e){}
  }
  if(!document.getElementById('settingsJsonInput').value){
    try {
      document.getElementById('settingsJsonInput').value = JSON.stringify({
        roles: document.getElementById('rolesInput') ? document.getElementById('rolesInput').value : '',
        group_count: (document.getElementById('groupCount') ? document.getElementById('groupCount').value : '')
      });
    } catch(e){}
  }
  if(!document.getElementById('orderJsonInput').value){
    try {
      const orderText = document.getElementById('orderOutput').value || '';
      const names = orderText.split(/\r?\n/).map(l=>l.replace(/^\d+\.\s*/,'')).filter(Boolean);
      document.getElementById('orderJsonInput').value = JSON.stringify(names.map((n,i)=>({name:n, order:i+1})));
    }catch(e){}
  }
  if(!document.getElementById('historyJsonInput').value){
    try{ document.getElementById('historyJsonInput').value = JSON.stringify(shufflyHistory); }catch(e){}
  }

  const titleField = document.getElementById('hiddenEventTitle');
  if(titleField) titleField.value = document.getElementById('shareEventTitle').value;

  const payloadPreview = {
    members_json: document.getElementById('membersJsonInput').value,
    results_json: document.getElementById('resultsJsonInput').value,
    order_json: document.getElementById('orderJsonInput').value,
    settings_json: document.getElementById('settingsJsonInput').value,
    history_json: document.getElementById('historyJsonInput').value,
    title: document.getElementById('hiddenEventTitle') ? document.getElementById('hiddenEventTitle').value : ''
  };

  if(IS_SIGNED_IN){
    const form = document.getElementById('saveForm');
    if(form) {
      form.submit();
    } else {
      showToast("フォームが見つかりません");
    }
  } else {
    try {
      localStorage.setItem('pending_shuffly_event', JSON.stringify(payloadPreview));
      const loginUrl = "<%= new_user_session_path %>?redirect_to=" + encodeURIComponent(window.location.href);
      window.location.href = loginUrl;
    } catch(e){
      showToast("保存処理に失敗しました");
    }
  }
}

// 初期化 / イベントバインド
window.onload = () => {
  const histField = document.getElementById('historyJsonInput');
  if(histField && histField.value){
    try {
      shufflyHistory = JSON.parse(histField.value);
      currentHistoryIndex = shufflyHistory.length - 1;
      if (currentHistoryIndex >= 0) {
        const mi = document.getElementById('membersInput');
        if(mi) mi.value = shufflyHistory[currentHistoryIndex];
      }
    } catch(e) {
      shufflyHistory=[]; currentHistoryIndex=-1;
    }
  }
  updateParticipantCount();
  if(shufflyHistory.length === 0) pushToHistory();
  // 初回読み込みではグループ表示/統計は自動表示しない（グループ分け実行後に表示される）
  switchResultTab('groups');
  switchSettingsTab('groups');

  if(IS_SIGNED_IN){
    const pending = localStorage.getItem('pending_shuffly_event');
    if(pending){
      try {
        const p = JSON.parse(pending);
        if(p.members_json) document.getElementById('membersJsonInput').value = p.members_json;
        if(p.results_json) document.getElementById('resultsJsonInput').value = p.results_json;
        if(p.order_json) document.getElementById('orderJsonInput').value = p.order_json;
        if(p.settings_json) document.getElementById('settingsJsonInput').value = p.settings_json;
        if(p.history_json) document.getElementById('historyJsonInput').value = p.history_json;
        if(p.title && document.getElementById('hiddenEventTitle')) document.getElementById('hiddenEventTitle').value = p.title;
        const form = document.getElementById('saveForm');
        if(form){
          localStorage.removeItem('pending_shuffly_event');
          form.submit();
        }
      } catch(e){
        // ignore
      }
    }
  }
};

(function(){
  function bindIf(id, evt, handler){
    const el = document.getElementById(id);
    if(el) el.addEventListener(evt, handler);
  }

  // メンバー編集時は表示の自動更新を行わない（グループ表示は「グループ分け実行」で反映）
  bindIf('membersInput', 'input', ()=>{ updateParticipantCount(); pushToHistory(); });
  bindIf('groupCount', 'input', ()=>{ updateParticipantCount(); /* do not auto-show groups/stats */ });
  bindIf('customGroupNames', 'input', ()=>{ /* no automatic group display */ });
  bindIf('rolesInput', 'input', ()=>{
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value=JSON.stringify({
      roles:document.getElementById('rolesInput').value,
      group_count: buildGroupIdsAndNames().groupCount
    });
  });

  // Import / paste (prevent default for link-style triggers)
  bindIf('btn-trigger-import', 'click', (e)=>{ e.preventDefault(); triggerImport(); });
  bindIf('importFile', 'change', handleImportFile);
  bindIf('btn-paste-clipboard', 'click', (e)=>{ e.preventDefault(); pasteFromClipboard(); });
  bindIf('btn-clear-history', 'click', (e)=>{ e.preventDefault(); clearMemberHistories(); });

  // Settings tabs
  bindIf('tab-settings-groups', 'click', ()=>switchSettingsTab('groups'));
  bindIf('tab-settings-order', 'click', ()=>switchSettingsTab('order'));
  bindIf('tab-settings-roles', 'click', ()=>switchSettingsTab('roles'));

  // Result tabs
  bindIf('tab-groups', 'click', ()=>switchResultTab('groups'));
  bindIf('tab-order', 'click', ()=>switchResultTab('order'));
  bindIf('tab-roles', 'click', ()=>switchResultTab('roles'));

  // Group view controls
  bindIf('showGroupLabel', 'change', ()=>{ /* no auto-refresh; group view updated after assignGroups */ });
  bindIf('separatorSelect', 'change', ()=>{ /* no auto-refresh; group view updated after assignGroups */ });
  bindIf('btn-copy-groupoutput', 'click', (e)=>{ e.preventDefault(); copyGroupOutput(); });
  bindIf('btn-copy-orderoutput', 'click', (e)=>{ e.preventDefault(); copyOrderOutput(); });
  bindIf('btn-copy-rolesoutput', 'click', (e)=>{ e.preventDefault(); copyRolesOutput(); });

  // Share controls
  bindIf('btn-toggle-presentation', 'click', (e)=>{ if(e) e.preventDefault(); togglePresentationMode(); });
  bindIf('btn-export-results', 'click', (e)=>{ if(e) e.preventDefault(); exportResults(); });
  bindIf('btn-save-results', 'click', (e)=>{ if(e) e.preventDefault(); saveResults(); });

  // Settings action buttons (find within containers and attach in order)
  const gAct = document.getElementById('settings-action-groups');
  if (gAct) {
    const btns = gAct.querySelectorAll('button, a[role="button"], a');
    if (btns[0]) btns[0].addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignGroups(); /* SPA: update panels without reload */ });
    if (btns[1]) btns[1].addEventListener('click', (e)=>{ if(e) e.preventDefault(); undoHistory(); /* keep on groups tab */ });
    if (btns[2]) btns[2].addEventListener('click', (e)=>{ if(e) e.preventDefault(); redoHistory(); /* keep on groups tab */ });
  }
  const oAct = document.getElementById('settings-action-order');
  if (oAct) {
    const b = oAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignOrder(); /* SPA: show order panel */ });
  }
  const rAct = document.getElementById('settings-action-roles');
  if (rAct) {
    const b = rAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignRoles(); /* SPA: show roles panel */ });
  }
})();
</script>