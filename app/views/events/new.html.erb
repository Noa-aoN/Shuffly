<div class="max-w-6xl mx-auto px-6 pt-2 pb-10">

  <!-- ヘッダ：アイコン + タイトル -->
  <h1 class="text-2xl md:text-3xl font-bold mb-8 flex items-center gap-2">
    <%= image_tag "icons/shuffle_24dp_1F1F1F.svg",
          width: 35,
          height: 35,
          class: "block" %>
    <span class="leading-none relative bottom-0.5">
      <%= @event.title.presence || "新規シャッフルイベント" %>
    </span>
  </h1>

  <div class="flex flex-col gap-10">

    <!-- ① メンバー入力エリア（表示用と内部保存用の textarea を分離） -->
    <div class="bg-white rounded-lg shadow-sm px-10 pt-8 pb-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">1</div>
        <h2 class="text-xl md:text-2xl font-semibold">メンバーを入力する</h2>
      </div>

      <label class="block mb-2 font-semibold text-gray-600"><span class="text-sm text-blue-500">●</span> メンバーリスト</label>

      <!-- 内部保存用（hidden）: JSON を保持 → この値を基に処理する -->
      <textarea id="membersRaw" rows="10" class="hidden" style="display:none;"><%= begin
        members = @event.members_json.present? ? JSON.parse(@event.members_json) : []
        members.map do |m|
          if m.is_a?(Hash)
            name = m["name"]
            hist = m["history"]&.join("") || ""
            "#{name}#{hist}"
          else
            m
          end
        end.join("\n")
      rescue JSON::ParserError
        ""
      end %></textarea>

      <!-- 表示用 textarea: ユーザが編集する領域。内部データは membersRaw と同期 -->
      <textarea id="membersInput" rows="10" class="w-full border border-slate-300 rounded-lg px-3 py-2" placeholder="例：メンバー1, メンバー2, ..."></textarea>
      <p class="text-sm text-gray-500 mb-5">↑ 改行またはカンマ区切りで、ユニークなメンバー名を入力してください。</p>
      <div id="memberCountHint" class="text-base text-yellow-800 mt-1 mb-5 bg-yellow-100 border-2 border-dashed border-yellow-200 rounded-lg px-4 py-2">現在のメンバー数：<span class="font-bold">未入力</span></div>

      <!-- インポート / サンプルデータ入力 / 履歴クリア用トリガ -->
      <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
        <a href="#" id="btn-insert-sample" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">サンプルデータを入力</a>
        <a href="#" id="btn-trigger-import" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">テキスト/CSVから入力</a>
        <input id="importFile" type="file" accept=".txt,.csv" class="hidden">
        <a href="#" id="btn-clear-history" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">履歴をクリア</a>
      </div>
    </div>

    <!-- ② 設定エリア（タブ切替でグループ / 順番 / 役割） -->
    <div class="bg-white rounded-lg shadow-sm px-10 pt-8 pb-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">2</div>
        <h2 class="text-xl md:text-2xl font-semibold">設定して実行する</h2>
      </div>

      <!-- タブボタン（表示切替）: 均等配置・リンク風 -->
      <div class="flex mb-5 border-b border-gray-200">
        <button id="tab-settings-groups" class="flex-1 flex items-center justify-center gap-2 px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-blue-500 text-gray-600 font-semibold hover:underline">
          <%= image_tag "icons/diversity_3_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">グループ</span>
        </button>
        <button id="tab-settings-order"  class="flex-1 flex items-center justify-center gap-2 px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-transparent text-gray-600 font-semibold hover:underline">
          <%= image_tag "icons/format_list_numbered_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">順番</span>
        </button>
        <button id="tab-settings-roles"  class="flex-1 flex items-center justify-center gap-2 px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-transparent text-gray-600 font-semibold hover:underline">
          <%= image_tag "icons/badge_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">役割</span>
        </button>
      </div>

      <!-- グループ設定パネル -->
      <div id="panel-settings-groups" class="settings-panel">
        <div class="mb-4">
          <label class="block mb-2 font-semibold text-gray-600"><span class="text-sm text-blue-500">●</span> グループ分けオプション</label>
          <div class="flex flex-col gap-3 mb-2">
            <div>
              <label class="text-sm text-gray-600">グループ数*</label>
              <input id="groupCount" type="number" min="1" max="26" value="<%= @event.group_count.presence || 3 %>" class="mt-1 w-full border border-slate-300 rounded-lg px-2 py-1 mb-1">
              <p class="text-sm text-gray-500 mb-1">↑ 26グループが最大です。</p>
            </div>
            <div>
              <label class="text-sm text-gray-600">グループ名（任意）</label>
              <textarea id="customGroupNames" rows="2" class="w-full border border-slate-300 rounded-lg px-2 py-1 mt-1" placeholder="例：グループA, グループB, ..."></textarea>
              <p class="text-sm text-gray-500 mb-1">↑ 改行またはカンマ区切りで入力してください。入力があるとグループ数が無視され、グループ名の数が反映されます。</p>
            </div>
          </div>

          <div>
            <label class="text-sm text-gray-600">分散固定メンバー（任意）</label>
            <textarea id="fixedMembersInput" rows="2" class="w-full border border-slate-300 rounded-lg px-2 py-1 mt-1" placeholder="例：メンバー3, メンバー5, ..."></textarea>
            <p class="text-sm text-gray-500 mb-6">↑ 改行またはカンマ区切りで入力してください。入力メンバーは可能な限り分散して各グループに固定されます。</p>
          </div>

          <div id="groupSizeHint" class="text-base text-yellow-800 mt-1 mb-5 bg-yellow-100 border-2 border-dashed border-yellow-200 rounded-lg px-4 py-2">現在の1グループあたり：<span class="font-bold">未計算</span></div>
          <p class="text-sm text-gray-500">※<span class="underline decoration-dashed">グループ分けは複数回実行可能です。ボタンを押すたびに被りが最小限になるように振り分け、履歴も保持されます。</span></p>
        </div>
      </div>

      <!-- 順番設定パネル -->
      <div id="panel-settings-order" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block mb-2 font-semibold text-gray-600"><span class="text-sm text-blue-500">●</span> 順番決めオプション</label>
          <div class="mb-2">
            <label class="text-sm text-gray-600">順番固定メンバー（任意）</label>
            <textarea id="fixedOrderInput" rows="3" class="w-full border border-slate-300 rounded-lg px-2 py-1 mt-1" placeholder="例：1:メンバー3, 5:メンバー1, ..."></textarea>
            <p class="text-sm text-gray-500 mt-1">↑ 改行またはカンマ区切りで「番号:メンバー名」と入力してください。固定指定します。無効な指定は無視されます。</p>
          </div>
          <p class="text-sm text-gray-500 mt-1">固定指定なしなら全員ランダムに順番が決まります。</p>
        </div>
      </div>

      <!-- 役割設定パネル -->
      <div id="panel-settings-roles" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block mb-2 font-semibold text-gray-600"><span class="text-sm text-blue-500">●</span> 役割決めオプション</label>
          <label class="text-sm text-gray-600">役割名*</label>
          <textarea id="rolesInput" rows="3" class="w-full border border-slate-300 rounded-lg px-2 py-1 mt-1" placeholder="例：司会, 書記, ..."><%= @event.setting_json["roles"] rescue "" %></textarea>
          <p class="text-sm text-gray-500 mt-1">↑ 改行またはカンマ区切りで役割名を入力してください。割り当てはランダムです。</p>
        </div>
      </div>

      <!-- 実行ボタン（パネルに応じて表示） -->
      <div id="settings-action-groups" class="mt-4">
        <div class="grid grid-cols-1 md:grid-cols-1 gap-2 mb-3 w-full md:place-items-center">
          <%= render 'shared/button',
            f: nil,
            button_text: 'グループ分け実行',
            id: nil,
            path: '#',
            variant: 'primary',
            full_mobile: true,
            extra_class: 'text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600',
            icon: 'icons/play_arrow_24dp_1F1F1F_FILL0_wght400_GRAD0_opsz24.svg',
            icon_class: 'inline-block' %>
        </div>
      </div>

      <div id="settings-action-order" class="mt-4 hidden">
        <div class="grid grid-cols-1 md:grid-cols-1 gap-2 mb-3 w-full md:place-items-center">
          <%= render 'shared/button',
            f: nil,
            button_text: '順番決め実行',
            id: nil,
            path: '#',
            variant: 'primary',
            full_mobile: true,
            extra_class: 'text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600',
            icon: 'icons/play_arrow_24dp_1F1F1F_FILL0_wght400_GRAD0_opsz24.svg',
            icon_class: 'inline-block' %>
        </div>
      </div>

      <div id="settings-action-roles" class="mt-4 hidden">
        <div class="grid grid-cols-1 md:grid-cols-1 gap-2 mb-3 w-full md:place-items-center">
          <%= render 'shared/button',
            f: nil,
            button_text: '役割決め実行',
            id: nil,
            path: '#',
            variant: 'primary',
            full_mobile: true,
            extra_class: 'text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600',
            icon: 'icons/play_arrow_24dp_1F1F1F_FILL0_wght400_GRAD0_opsz24.svg',
            icon_class: 'inline-block' %>
        </div>
      </div>
    </div>

    <!-- ③ 結果表示カード：グループ / 順番 / 役割 の切替表示 -->
    <div id="resultsCard" class="bg-gray-100 rounded-lg shadow-sm px-10 pt-8 pb-6">
      <div class="flex items-start justify-between mb-4">
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">3</div>
          <h2 class="text-xl md:text-2xl font-semibold">シャッフル結果をみる</h2>
        </div>
      </div>

      <!-- 結果タブ: 均等配置・リンク風 -->
      <div class="flex mb-5 border-b border-gray-200">
        <button id="tab-groups" class="flex-1 text-center px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-blue-500 text-gray-600 font-medium hover:underline">
          <%= image_tag "icons/diversity_3_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">グループ</span>
        </button>
        <button id="tab-order"  class="flex-1 text-center px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-transparent text-gray-600 hover:underline">
          <%= image_tag "icons/format_list_numbered_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">順番</span>
        </button>
        <button id="tab-roles"  class="flex-1 text-center px-3 py-2 -mb-px border-b-2 text-sm md:text-lg border-transparent text-gray-600 hover:underline">
          <%= image_tag "icons/badge_24dp_1F1F1F.svg", width: 24, height: 24, class: "inline-block relative bottom-0.5" %>
          <span class="leading-none">役割</span>
        </button>
      </div>

      <!-- グループ表示パネル -->
      <div id="panel-groups" class="result-panel">
        <h3 class="mb-2 font-semibold text-gray-600"><span class="text-sm text-blue-500">●</span> グループ表示</h3>

        <!-- グループ結果出力（初期は空。実行後に内容が入る） -->
        <textarea id="groupOutput" rows="10" readonly class="bg-yellow-100 text-gray-500 border  border-slate-300 rounded-lg px-3 py-2 w-full mb-4 text-lg"></textarea>

        <!-- グループ表示オプション -->
        <div class="mb-6">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">
              <a href="#" id="btn-toggle-options" class="inline-flex items-center gap-2 hover:underline" aria-expanded="false">
                <span id="btn-toggle-options-text" class="text-gray-600"><span class="text-sm text-blue-500">●</span> グループ表示オプション</span>
                <%= image_tag "icons/expand_more_24dp_1F1F1F.svg", width: 20, height: 20, id: "btn-toggle-options-icon", class: "inline-block" %>
              </a>
            </h3>
          </div>

          <!-- このコンテナを折りたたむ／表示する -->
          <div id="optionsContainer" class="hidden">
            <h3 class="mb-2 font-semibold sr-only">グループ表示オプション（詳細）</h3>
            <div class="flex flex-col sm:flex-row sm:items-center gap-2">
              <label class="inline-flex items-center gap-1 mt-2">
                <input type="checkbox" id="showGroupLabel" checked class="rounded border-gray-300">
                <span class="text-sm ml-1 mr-3">グループ名表示</span>
              </label>
              <label class="inline-flex items-center gap-1 mt-2">
                <input type="checkbox" id="showGroupCount" checked class="rounded border-gray-300">
                <span class="text-sm ml-1 mr-3">グループ人数表示</span>
              </label>
              <label class="inline-flex items-center gap-1 mt-2">
                <input type="checkbox" id="breakMemberLine" checked class="rounded border-gray-300">
                <span class="text-sm ml-1 mr-3">メンバーを改行表示</span>
              </label>
            </div>

            <div class="mt-2 flex flex-col sm:flex-row sm:items-start gap-3">
              <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
                <label class="text-sm mr-0 sm:mr-2 mb-1 sm:mb-0">メンバーの区切り方 :</label>
                <select id="separatorSelect" class="border rounded-lg px-2 py-1 mt-0 sm:mt-1 w-full sm:w-auto min-w-40">
                  <option value="," selected>カンマ</option>
                  <option value=" " >スペース</option>
                  <option value="  ">ダブルスペース</option>
                  <option value="\\t">タブ</option>
                  <option value="\\n">改行</option>
                </select>
              </div>

              <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
                <label class="text-sm mr-0 sm:mr-2 mb-1 sm:mb-0">グループの区切り方 :</label>
                <select id="groupSeparatorSelect" class="border rounded-lg px-2 py-1 mt-0 sm:mt-1 w-full sm:w-auto min-w-40">
                  <option value="none" selected>なし</option>
                  <option value="space">空行</option>
                  <option value="line">線</option>
                  <option value="wave">波線</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- 統計情報（折りたたみ） -->
        <div class="mb-5">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">
              <a href="#" id="btn-toggle-stats" class="inline-flex items-center gap-2 hover:underline" aria-expanded="false">
                <span id="btn-toggle-stats-text" class="text-gray-600"><span class="text-sm text-blue-500">●</span> 統計情報</span>
                <%= image_tag "icons/expand_more_24dp_1F1F1F.svg", width: 20, height: 20, id: "btn-toggle-stats-icon", class: "inline-block" %>
              </a>
            </h3>
          </div>
          <div id="statsContainer" class="hidden">
            <textarea id="statsOutput" rows="10" readonly class="bg-yellow-100 text-gray-500 border border-slate-300 rounded-lg px-3 py-2 w-full text-sm mb-2"></textarea>
          </div>
        </div>

        <!-- グループ分けの回次表示（memberCountHint と同じスタイル） -->
        <div id="groupRoundHint" class="text-base text-yellow-800 mt-1 mb-5 bg-yellow-100 border-2 border-dashed border-yellow-200 rounded-lg px-4 py-2">現在のグループ分け表示：<span class="font-bold">未実施</span></div>

        <!-- 結果操作リンク -->
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <a href="#" id="btn-prev-group" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">前回のグループ分け</a>
          <a href="#" id="btn-next-group" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">次回のグループ分け</a>
          <a href="#" id="btn-copy-groupoutput" class="w-full sm:flex-1 text-center text-base text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>

      </div>

      <!-- 順番表示パネル -->
      <div id="panel-order" class="result-panel hidden">
        <h3 class="font-semibold mb-2 text-gray-600"><span class="text-sm text-blue-500">●</span> 順番表示</h3>
        <textarea id="orderOutput" rows="10" readonly class="bg-yellow-100 text-gray-500 border border-slate-300 rounded-lg px-3 py-2 w-full text-lg"></textarea>
        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-orderoutput" class="text-base text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>

      <!-- 役割表示パネル -->
      <div id="panel-roles" class="result-panel hidden">
        <h3 class="font-semibold mb-2 text-gray-600"><span class="text-sm text-blue-500">●</span> 役割表示</h3>
        <textarea id="rolesOutput" rows="10" readonly class="bg-yellow-100 text-gray-500 border border-slate-300 rounded-lg px-3 py-2 w-full text-lg"></textarea>
        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-rolesoutput" class="text-base text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>
    </div>

    <!-- ④ 出力 / 共有 / 保存 -->
    <div class="bg-gray-100 rounded-lg shadow-sm px-10 pt-8 pb-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">4</div>
        <h2 class="text-xl md:text-2xl font-semibold">共有 / 出力 / 保存する</h2>
      </div>

      <label class="block font-semibold mb-2 text-gray-600"><span class="text-sm text-blue-500">●</span> イベントタイトル（任意）</label>
      <input id="shareEventTitle" type="text" value="<%= @event.title %>" class="w-full border border-slate-300 rounded-lg px-3 py-2 mb-1 bg-white" placeholder="例：〇〇イベント">
      <p class="text-sm mb-4 text-gray-500">↑ 結果共有やイベント保存のタイトル・出力テキストファイル名を設定できます。</p>
      <p class="text-sm mb-4 text-gray-500">※<span class="underline decoration-dashed">イベント保存にはログインが必要です。</span></p>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-2 mb-2 w-full md:place-items-center">
        <%= render 'shared/button',
              f: nil,
              button_text: '結果共有表示',
              id: 'btn-toggle-presentation',
              path: '#',
              variant: 'secondary',
              full_mobile: true,
              extra_class: 'text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50',
              icon: 'icons/share_24dp_1F1F1F_FILL0_wght400_GRAD0_opsz24.svg',
              icon_class: 'inline-block' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'イベント保存',
              id: 'btn-save-results',
              path: '#',
              variant: 'primary',
              full_mobile: true,
              extra_class: 'text-center px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600',
              icon: 'icons/save_24dp_1F1F1F.svg',
              icon_class: 'inline-block' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'テキスト出力',
              id: 'btn-export-results',
              path: '#',
              variant: 'secondary',
              full_mobile: true,
              extra_class: 'text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50',
              icon: 'icons/download_2_24dp_1F1F1F_FILL0_wght400_GRAD0_opsz24.svg',
              icon_class: 'inline-block' %>
      </div>

      <!-- 非表示の保存フォーム（JS が submit を呼ぶ） -->
      <%= form_with(model: @event, local: true, html: { id: 'saveForm', style: 'display:none' }) do |f| %>
        <%= f.hidden_field :members_json, id: 'membersJsonInput' %>
        <%= f.hidden_field :member_results_json, id: 'resultsJsonInput' %>
        <%= f.hidden_field :member_order_json, id: 'orderJsonInput' %>
        <%= f.hidden_field :setting_json, id: 'settingsJsonInput' %>
        <%= f.hidden_field :history_json, id: 'historyJsonInput' %>
        <%= f.hidden_field :title, value: @event.title, name: 'event[title]', id: 'hiddenEventTitle' %>
      <% end %>
    </div>

  </div>

  <!-- トースト通知領域（幅を内容に合わせる・モバイル対応） -->
  <div id="toast" class="fixed left-1/2 transform -translate-x-1/2 bg-white text-black border border-default shadow-xs text-sm dm:text-lg opacity-0 transition-opacity rounded-lg" style="display:inline-block; max-width:90vw; width:auto; white-space:pre-wrap; text-align:center; padding:1rem; box-sizing:border-box;"></div>
</div>

<script>
/*
  JavaScript 部分：UI / データ変換 / 操作ロジック
  - 内部データは membersRaw（hidden textarea）に保持
  - 表示用は membersInput（ユーザ編集領域）
  - グループ割当・順番・役割はそれぞれ assignGroups / assignOrder / assignRoles
  - 表示切替は switchResultTab / switchSettingsTab
*/

let shufflyHistory = [], currentHistoryIndex = -1;
const IS_SIGNED_IN = <%= user_signed_in? ? 'true' : 'false' %>;
let statsCollapsed = true; // 統計は初期折りたたみ
let optionsCollapsed = true; // グループ表示オプションは初期折りたたみ（デフォルト閉じる）
let groupsAssigned = false; // 変更：グループ分け実行が行われたかどうかのフラグ

// アイコンパス（assets pipeline 経由）
const ICON_EXPAND = "<%= asset_path('icons/expand_more_24dp_1F1F1F.svg') %>";
const ICON_COLLAPSE = "<%= asset_path('icons/keyboard_arrow_up_24dp_1F1F1F.svg') %>";

// --- ユーティリティ ---
function clampGroupCount(v){
  return Math.min(Math.max(parseInt(v) || 1, 1), 26);
}
function parseEntry(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  return {name, history: hist};
}
function getCurrentRound(entries){
  let max=0;
  for(const e of entries) for(const h of e.history) {
    const m = h.match(/^#(\d+)/);
    if(m) max=Math.max(max, parseInt(m[1]));
  }
  return max+1;
}
function getCoOccurrenceMap(entries, ignoreLast=true){
  const map={}, histories={};
  for(const e of entries) histories[e.name]=ignoreLast?e.history.slice(0,-1):e.history;
  for(const e of entries) map[e.name]={};
  for(const a of entries){
    for(const b of entries){
      if(a.name===b.name) continue;
      const overlap=histories[a.name].filter(h=>histories[b.name].includes(h));
      map[a.name][b.name]=overlap.length;
    }
  }
  return map;
}

// 新規: 履歴内で「1回目のグループ割当」が最初に発生したインデックスを返す
function findFirstGroupHistoryIndex(){
  for(let i=0;i<shufflyHistory.length;i++){
    const v = shufflyHistory[i] || "";
    if(/#1[A-Z]/.test(v)) return i;
  }
  // 無ければ 0 を返し、従来の振る舞い（先頭まで戻れる）と互換性を保つ
  return 0;
}

// グループIDと表示名を決定（A,B,C...）
function buildGroupIdsAndNames(){
  const groupCountInputEl = document.getElementById('groupCount');
  const inputGroupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  const customNamesEl = document.getElementById('customGroupNames');
  const customNames = (customNamesEl ? customNamesEl.value : "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);

  let groupCount;
  let ids = [];
  let displayNames = [];

  if(customNames.length > 0){
    groupCount = Math.min(customNames.length, 26);
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = customNames.slice(0, groupCount);
  } else {
    groupCount = inputGroupCount;
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = ids.slice();
  }

  const idToName = {};
  ids.forEach((id, idx) => idToName[id] = displayNames[idx] || id);
  return { ids, displayNames, idToName, groupCount };
}

// 表示用履歴フォーマット処理（表示 ↔ 内部 raw の相互変換）
let suppressDisplayInput = false;
function getRawValue(){ return (document.getElementById('membersRaw') || {value:''}).value || ""; }
function setRawValue(v){ const el = document.getElementById('membersRaw'); if(el) el.value = v; }
function getDisplayValue(){ return (document.getElementById('membersInput') || {value:''}).value || ""; }
function setDisplayValue(v){ const el = document.getElementById('membersInput'); if(el) el.value = v; }

// 表示用に履歴を整形
function formatEntryForDisplay(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  const { idToName } = buildGroupIdsAndNames();
  const formattedHist = hist.map(h=>{
    const m=h.match(/^#(\d+)([A-Z])$/);
    if(m){
      const num=m[1], id=m[2];
      const gname = idToName[id] || id;
      return ` [ ${num}回目：${gname} ]`;
    }
    return h;
  }).join('');
  return `${name}${formattedHist}`;
}

function updateDisplayFromRaw(){
  const raw = getRawValue();
  const lines = raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const formatted = lines.map(formatEntryForDisplay).join("\n");
  suppressDisplayInput = true;
  setDisplayValue(formatted);
  setTimeout(()=>{ suppressDisplayInput = false; }, 0);
}

function parseDisplayToRaw(displayText){
  const { idToName } = buildGroupIdsAndNames();
  const nameToId = {};
  for(const k in idToName) nameToId[idToName[k]] = k;

  const lines = displayText.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const rawLines = lines.map(line=>{
    const parts = line.split('#').filter(Boolean);
    if(parts.length === 0) return "";
    const base = parts[0].trim();
    const tokens = parts.slice(1);
    const rawTokens = tokens.map(tok=>{
      const mRaw = tok.match(/^(\d+)([A-Z])$/);
      if(mRaw) return `#${mRaw[1]}${mRaw[2]}`;
      const m = tok.match(/^(\d+)\s*巡目\s*[:：]\s*(.+)$/);
      if(m){
        const num=m[1];
        const gname = m[2].trim();
        let id = nameToId[gname];
        if(!id){
          const stripped = gname.replace(/^グループ\s*/i,'').trim();
          id = nameToId[stripped];
        }
        if(id) return `#${num}${id}`;
        return `#${num}`;
      }
      return `#${tok.replace(/^#?/,'')}`;
    }).filter(Boolean);
    return base + rawTokens.join('');
  }).filter(Boolean);
  return rawLines.join("\n");
}

function setRawAndRefreshDisplay(rawText){
  setRawValue(rawText);
  updateDisplayFromRaw();
}

// --- コア処理: グループ / 順番 / 役割 ---
function assignGroups(){
  let raw = getRawValue().trim();
  let rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];

  // 追加: メンバーが空ならトースト表示のみ行い、グループ表示はクリアして処理を中断する
  if(rawList.length === 0){
    showToast("メンバーがいません");
    const gOut = document.getElementById('groupOutput');
    const sOut = document.getElementById('statsOutput');
    const gr = document.getElementById('groupRoundHint');
    if(gOut) gOut.value = "";
    if(sOut) sOut.value = "";
    if(gr) gr.innerHTML = '現在のグループ分け表示：<span class="font-bold">未実施</span>';
    groupsAssigned = false;
    return;
  }

  let entries = rawList.map(parseEntry);
  const round=getCurrentRound(entries);

  const { ids: groupIds, idToName, groupCount } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  const coMap=getCoOccurrenceMap(entries);

  const fixedRaw = (document.getElementById('fixedMembersInput').value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedSet = new Set(fixedRaw);
  const fixedEntries = entries.filter(e=>fixedSet.has(e.name));
  const otherEntries = entries.filter(e=>!fixedSet.has(e.name));

  function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // 変更点：分散固定メンバーは初回はランダムに各グループへ割当てるが、
  // 2回目以降はできるかぎり直前の割当（履歴の最後のグループ）に固定する。
  // ただしバランスが大きく崩れる場合は空きグループや最小グループへ割当てる。
  for(const p of fixedEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    let chosen = null;

    // 最後の履歴から直前のグループを取得
    const last = p.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    const preferred = m ? m[1] : null;

    if(preferred && groupIds.includes(preferred)){
      // 現在の最小グループサイズを取得
      const minSize = Math.min(...groupIds.map(g=>groups[g].length));
      // できるだけ同じグループに戻す：ただしそのグループが最小サイズよりも大きすぎるときは避ける
      // （バランスを保つために minSize + 1 を許容上限とする）
      if(groups[preferred].length <= minSize + 1){
        chosen = preferred;
      } else if(emptyGroups.length > 0){
        chosen = pickRandom(emptyGroups);
      } else {
        const candidates = groupIds.filter(g=>groups[g].length===minSize);
        chosen = pickRandom(candidates);
      }
    } else {
      // preferred が無い（初回）または無効な場合は既存のルールに従う
      if(emptyGroups.length>0){
        chosen = pickRandom(emptyGroups);
      } else {
        const minSize = Math.min(...groupIds.map(g=>groups[g].length));
        const candidates = groupIds.filter(g=>groups[g].length===minSize);
        chosen = pickRandom(candidates);
      }
    }

    if(!chosen){
      // 最終手段：最小グループに入れる
      const minSize = Math.min(...groupIds.map(g=>groups[g].length));
      const candidates = groupIds.filter(g=>groups[g].length===minSize);
      chosen = pickRandom(candidates);
    }

    groups[chosen].push(p);
    p.assignedGroup = chosen;
  }

  for(const p of otherEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    if(emptyGroups.length>0){
      const chosen = pickRandom(emptyGroups);
      groups[chosen].push(p);
      p.assignedGroup = chosen;
      continue;
    }

    const minSize=Math.min(...groupIds.map(g=>groups[g].length));
    const candidates=groupIds.filter(g=>groups[g].length===minSize);

    let minMK=Infinity;
    const scores=[];
    for(const g of candidates){
      const mk=groups[g].reduce((acc,q)=>acc+(coMap[p.name][q.name]||0),0);
      scores.push({g, mk});
      if(mk<minMK) minMK=mk;
    }
    const tied = scores.filter(s=>s.mk===minMK).map(s=>s.g);
    const selected = pickRandom(tied);
    groups[selected].push(p);
    p.assignedGroup = selected;
  }

  // 役割がある場合は順番に割当
  const rolesForGroups = document.getElementById('rolesInput').value.split(/[\r\n,]+/).map(r=>r.trim()).filter(Boolean);
  if(rolesForGroups.length>0){
    for(const g of groupIds){
      const members=groups[g];
      members.forEach((m,i)=>m.role=rolesForGroups[i%rolesForGroups.length]);
    }
  }

  // 履歴追記を反映して内部 raw を更新
  const updated = entries.map(e => {
    const assigned = e.assignedGroup || (()=>{
      for(const g of groupIds) if(groups[g].some(x=>x.name===e.name)) return g;
      return groupIds[0];
    })();
    return `${e.name}${e.history.join('')}#${round}${assigned}`;
  });

  setRawAndRefreshDisplay(updated.join("\n"));

  // 変更点：グループ分けが実行されたことをフラグに記録
  groupsAssigned = true;

  try{
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: groups, group_names: buildGroupIdsAndNames().idToName });
    document.getElementById('settingsJsonInput').value = JSON.stringify({
      roles: document.getElementById('rolesInput').value,
      group_count: groupCount,
      custom_group_names: (document.getElementById('customGroupNames').value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean)
    });
  }catch(e){
    console.warn("JSON シリアライズ失敗:", e);
  }

  updateParticipantCount(); showGroups(); showStats(); pushToHistory();
  // 追加: 実行成功時にトースト表示
  showToast("グループに振り分けました");
  switchResultTab('groups');
}

function assignOrder(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length === 0){
    document.getElementById('orderOutput').value = "";
    if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = "[]";
    showToast("メンバーがいません");
    return;
  }

  const fixedRaw = (document.getElementById('fixedOrderInput')?.value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedMap = {};
  const invalids = [];
  for(const line of fixedRaw){
    if(!line) continue;
    const m = line.match(/^(\d+)\s*[:=]\s*(.+)$/) || line.match(/^(\d+)\s+(.+)$/);
    if(m){
      const pos = parseInt(m[1],10);
      const name = m[2].trim();
      if(pos >= 1 && pos <= members.length){
        fixedMap[pos] = name;
      } else {
        invalids.push(line);
      }
    } else {
      invalids.push(line);
    }
  }

  const namesSet = new Set(members);
  const assignedFixedNames = new Set();
  const invalidNameEntries = [];
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    const name = fixedMap[pos];
    if(!namesSet.has(name)){
      invalidNameEntries.push(`${pos}: ${name}`);
      delete fixedMap[pos];
    } else {
      assignedFixedNames.add(name);
    }
  }

  if(invalids.length>0 || invalidNameEntries.length>0){
    const msgs = [];
    if(invalids.length>0) msgs.push("固定指定の書式が不正な行があります");
    if(invalidNameEntries.length>0) msgs.push("メンバーに存在しない名前の固定指定があります");
    showToast(msgs.join('、') + "（無視されます）");
  }

  const pool = members.filter(m=>!assignedFixedNames.has(m));
  for(let i=pool.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [pool[i], pool[j]]=[pool[j], pool[i]];
  }

  const result = Array(members.length).fill(null);
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    result[pos-1] = fixedMap[pos];
  }

  let poolIdx = 0;
  for(let i=0;i<result.length;i++){
    if(result[i] === null){
      result[i] = pool[poolIdx++] || "";
    }
  }

  const lines = result.map((name, idx) => `${idx+1}. ${name}`);
  document.getElementById('orderOutput').value = lines.join("\n");

  const orderJson = result.map((name, idx) => ({ name, order: idx+1 }));
  if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = JSON.stringify(orderJson);

  showToast("順番を割り当てました");
  switchResultTab('order');
}

function assignRoles(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length===0){ showToast("メンバーがいません"); return; }

  const roles = document.getElementById('rolesInput').value.split(/[\r\n,]+/).map(r=>r.trim()).filter(Boolean);
  if(roles.length===0){ showToast("役割が未入力です"); return; }

  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]]=[arr[j], arr[i]];
    }
  }

  const pool = members.slice();
  shuffleArray(pool);

  const assignments = [];
  for(let i=0;i<roles.length && i<pool.length;i++){
    assignments.push({ name: pool[i], role: roles[i] });
  }
  const assignedNames = new Set(assignments.map(a=>a.name));
  for(const m of members){
    if(!assignedNames.has(m)) assignments.push({ name: m, role: null });
  }

  const displayLines = assignments.map(a => a.role ? `${a.name}: ${a.role}` : `${a.name}: `);
  document.getElementById('rolesOutput').value = displayLines.join("\n");

  try {
    const settingsField = document.getElementById('settingsJsonInput');
    let settings = {};
    if(settingsField && settingsField.value) {
      try { settings = JSON.parse(settingsField.value); } catch(e){ settings = {}; }
    }
    settings.role_assignments = assignments.map(a => ({ name: a.name, role: a.role }));
    if(settingsField) settingsField.value = JSON.stringify(settings);
  } catch(e){
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value = JSON.stringify({ role_assignments: assignments.map(a=>({ name:a.name, role: a.role })) });
  }

  showToast("役割を割り当てました");
  switchResultTab('roles');
}

function showGroups(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries = rawList.map(parseEntry);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)) {
      let empty = groupIds.find(g=>groups[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groups[g].length));
        id = groupIds.find(g=>groups[g].length===minSize);
      }
    }
    groups[id].push(e.name);
  }

  const sepVal = document.getElementById('separatorSelect').value;
  // sepVal が "\\n" や "\\t" のようにエスケープ表現で入っている場合でも
  // 正しく改行・タブ文字に変換して表示する
  let memberSep;
  if (sepVal === '\\t' || sepVal === '\\\\t' || sepVal === '\t') {
    memberSep = '\t';
  } else if (sepVal === '\\n' || sepVal === '\\\\n' || sepVal === '\n') {
    memberSep = '\n';
  } else {
    memberSep = sepVal;
  }

  const showLabel=document.getElementById('showGroupLabel').checked;
  const showCount=document.getElementById('showGroupCount') ? document.getElementById('showGroupCount').checked : true;
  const breakMemberLine = document.getElementById('breakMemberLine') ? document.getElementById('breakMemberLine').checked : true;
  const groupSepVal = document.getElementById('groupSeparatorSelect') ? document.getElementById('groupSeparatorSelect').value : 'space';

  let groupSep = '\n\n';
  if(groupSepVal === 'none') groupSep = '\n';
  else if(groupSepVal === 'space') groupSep = '\n\n';
  else if(groupSepVal === 'line') groupSep = '\n────────\n';
  else if(groupSepVal === 'wave') groupSep = '\n〜〜〜〜〜〜〜\n';

  const parts = [];
  for(const id of groupIds){
    const members=groups[id];
    const label = idToName[id] || id;
    let block = '';
    if(showLabel){
      const countText = showCount ? `（${members.length}人）` : '';
      block += breakMemberLine ? `${label}${countText}：\n` : `${label}${countText}： `;
    }
    block += members.join(memberSep);
    parts.push(block);
  }

  const display = parts.join(groupSep);
  document.getElementById('groupOutput').value=display.trim();

  // 回次表示を更新
  updateGroupRoundDisplay();
}

function showStats(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries=rawList.map(parseEntry);
  const coMap=getCoOccurrenceMap(entries,true);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groupMap=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)){
      let empty = groupIds.find(g=>groupMap[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groupMap[g].length));
        id = groupIds.find(g=>groupMap[g].length===minSize);
      }
    }
    groupMap[id].push(e.name);
  }

  const groupSepVal = document.getElementById('groupSeparatorSelect') ? document.getElementById('groupSeparatorSelect').value : 'space';
  let groupSep = '\n\n';
  if(groupSepVal === 'none') groupSep = '\n';
  else if(groupSepVal === 'space') groupSep = '\n\n';
  else if(groupSepVal === 'line') groupSep = '\n────────\n';
  else if(groupSepVal === 'wave') groupSep = '\n〜〜〜〜〜〜〜\n';

  const parts = [];
  for(const id of groupIds){
    const members=groupMap[id];
    let total=0;
    const memberLines = [];
    for(const m of members){
      const mk=members.reduce((sum,other)=>sum+(m!==other?(coMap[m][other]||0):0),0);
      memberLines.push(`${m}：同グループ回数＝${mk}`);
      total+=mk;
    }
    const header = `${idToName[id] ? `グループ ${idToName[id]}` : `グループ ${id}`}（同グループ回数平均＝${members.length? (total/members.length).toFixed(2):0}）：`;
    const block = [header].concat(memberLines).join("\n");
    parts.push(block);
  }

  document.getElementById('statsOutput').value = parts.join(groupSep).trim();

  // 回次表示を更新
  updateGroupRoundDisplay();
}

// 新規: グループ分け回次を計算して表示するヘルパ
function getDisplayRound(entries){
  let max = 0;
  let found = false;
  for(const e of entries){
    for(const h of e.history){
      const m = h.match(/^#(\d+)/);
      if(m){
        found = true;
        const num = parseInt(m[1],10);
        if(num > max) max = num;
      }
    }
  }
  return found ? max : null;
}
function updateGroupRoundDisplay(){
  const el = document.getElementById('groupRoundHint');
  if(!el) return;
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries = rawList.map(parseEntry);
  const round = getDisplayRound(entries);
  if(round === null){
    el.innerHTML = '現在のグループ分け表示：<span class="font-bold">未実施</span>';
  } else {
    el.innerHTML = `現在のグループ分け表示：<span class="font-bold">${round}回目</span>`;
  }
}

function updateParticipantCount(){
  const raw = getRawValue().trim();
  const count = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean).length : 0;
  const span=document.getElementById('groupSizeHint');
  const memberSpan=document.getElementById('memberCountHint');

  const customNamesEl = document.getElementById('customGroupNames');
  let groupCount;
  if(customNamesEl){
    const customNames = (customNamesEl.value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);
    if(customNames.length > 0) groupCount = Math.min(customNames.length, 26);
  }
  if(!groupCount){
    const groupCountInputEl = document.getElementById('groupCount');
    groupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  }

  if(memberSpan){
    if(count){
      memberSpan.innerHTML = `現在のメンバー数：<span class="font-bold">${count}人</span>`;
    } else {
      memberSpan.innerHTML = '現在のメンバー数：<span class="font-bold">未入力</span>';
    }
  }

  if(span){
    if(count === 0){
      span.innerHTML = '現在の1グループあたり：<span class="font-bold">未計算</span>';
    } else {
      const min=Math.floor(count/groupCount), max=Math.ceil(count/groupCount);
      if(min===max){
        span.innerHTML = `現在の1グループあたり：<span class="font-bold">${min}人</span>`;
      } else {
        span.innerHTML = `現在の1グループあたり：<span class="font-bold">${min}〜${max}人</span>`;
      }
    }
  }

  // 回次表示を更新（メンバーや履歴が変わったときに反映）
  updateGroupRoundDisplay();
}

function copyGroupOutput(){ navigator.clipboard.writeText(document.getElementById('groupOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyOrderOutput(){ navigator.clipboard.writeText(document.getElementById('orderOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyRolesOutput(){ navigator.clipboard.writeText(document.getElementById('rolesOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }

// showToast の位置を常に上から100pxの位置に表示するよう変更
function showToast(msg){
  const toast = document.getElementById('toast');
  if(!toast) return;
  // 優先して top を固定、bottom は解除
  toast.style.top = '35px';
  toast.style.bottom = 'auto';
  // 中央揃えの transform / left を確実に適用
  toast.style.left = '50%';
  // 前面に出す
  toast.style.zIndex = '1000';
  toast.textContent = msg;
  toast.classList.remove('opacity-0');
  setTimeout(()=>toast.classList.add('opacity-0'),1200);
}

function pushToHistory(){
  const text = getRawValue();
  // 変更: 履歴が空で現在の raw が空文字列の場合は履歴に追加しない
  if (shufflyHistory.length === 0 && text.trim() === "") return;
  if(currentHistoryIndex>=0 && shufflyHistory[currentHistoryIndex]===text) return;
  shufflyHistory = shufflyHistory.slice(0,currentHistoryIndex+1);
  shufflyHistory.push(text);
  currentHistoryIndex++;
  const histField = document.getElementById('historyJsonInput');
  if(histField) histField.value=JSON.stringify(shufflyHistory);
}

function undoHistory(){
  const firstIndex = findFirstGroupHistoryIndex();
  // 1回目より前へは戻れない（安全策）
  if(currentHistoryIndex <= firstIndex){
    showToast("これ以上戻れません");
    return;
  }
  currentHistoryIndex--;
  const val = shufflyHistory[currentHistoryIndex];
  // もし new index が 1回目より前になってしまった場合の安全策（念のため）
  if(currentHistoryIndex < firstIndex){
    // グループ表示領域をクリア／非表示化する
    const gOut = document.getElementById('groupOutput');
    const sOut = document.getElementById('statsOutput');
    const gr = document.getElementById('groupRoundHint');
    if(gOut) gOut.value = "";
    if(sOut) sOut.value = "";
    if(gr) gr.textContent = ''; // 非表示にする安全策
    // 内部 raw は履歴値に戻すが、グループ表示は表示しない
    setRawAndRefreshDisplay(val || "");
    updateParticipantCount();
    showToast("1ステップ戻しました");
    switchResultTab('groups');
    return;
  }

  setRawAndRefreshDisplay(val);
  updateParticipantCount();
  showGroups();
  showStats();
  try{
    const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
    if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}
  showToast("1ステップ戻しました");
  switchResultTab('groups');
}

function redoHistory(){
  if(currentHistoryIndex<shufflyHistory.length-1){
    currentHistoryIndex++;
    const val = shufflyHistory[currentHistoryIndex];
    setRawAndRefreshDisplay(val);
    updateParticipantCount();
    showGroups();
    showStats();
    try{
      const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
      if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    }catch(e){}
    showToast("1ステップ進めました");
    switchResultTab('groups');
  } else showToast("これ以上進めません");
}

function switchResultTab(name){
  document.querySelectorAll('.result-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-groups, #tab-order, #tab-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-semibold');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-groups').classList.remove('hidden'); const el=document.getElementById('tab-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }
  if(name==='order'){ document.getElementById('panel-order').classList.remove('hidden'); const el=document.getElementById('tab-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }
  if(name==='roles'){ document.getElementById('panel-roles').classList.remove('hidden'); const el=document.getElementById('tab-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }
}

function switchSettingsTab(name){
  document.querySelectorAll('.settings-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-settings-groups, #tab-settings-order, #tab-settings-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-semibold');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-settings-groups').classList.remove('hidden'); const el=document.getElementById('tab-settings-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }
  if(name==='order'){ document.getElementById('panel-settings-order').classList.remove('hidden'); const el=document.getElementById('tab-settings-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }
  if(name==='roles'){ document.getElementById('panel-settings-roles').classList.remove('hidden'); const el=document.getElementById('tab-settings-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-semibold'); }

  const gAct = document.getElementById('settings-action-groups');
  const oAct = document.getElementById('settings-action-order');
  const rAct = document.getElementById('settings-action-roles');
  if(gAct) gAct.classList.add('hidden');
  if(oAct) oAct.classList.add('hidden');
  if(rAct) rAct.classList.add('hidden');
  if(name==='groups' && gAct) gAct.classList.remove('hidden');
  if(name==='order' && oAct) oAct.classList.remove('hidden');
  if(name==='roles' && rAct) rAct.classList.remove('hidden');
}

function triggerImport(){ const f = document.getElementById('importFile'); if(f) f.click(); }
function handleImportFile(e){
  const file = e.target.files ? e.target.files[0] : null;
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const text = ev.target.result;
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + text.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("ファイルをインポートしました");
  };
  reader.readAsText(file, 'utf-8');
}
function pasteFromClipboard(){
  navigator.clipboard.readText().then(txt=>{
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + txt.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("クリップボードから貼り付けました");
  }).catch(()=>showToast("クリップボードにアクセスできません"));
}

/* --- 追加: サンプルデータ挿入機能（15人プール、ランダムで10人選択） --- */
function insertSampleData(){
  const confirmed = window.confirm("メンバーリスト欄にサンプルデータ10人分を上書きします。よろしいですか？");
  if(!confirmed) return;

  const samplePool = [
    "佐藤 太郎",
    "鈴木 花子",
    "高橋 一郎",
    "田中 愛",
    "伊藤 健",
    "渡辺 真由美",
    "山本 大輔",
    "中村 彩",
    "小林 翼",
    "加藤 恵",
    "斎藤 翔",
    "井上 真由",
    "木村 拓也",
    "清水 直子",
    "長谷川 智子"
  ];

  // Fisher-Yates shuffle
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const chosen = shuffle(samplePool).slice(0,10);
  const sample = chosen.join("\n");

  setRawAndRefreshDisplay(sample);
  updateParticipantCount();
  pushToHistory();
  try{
    const entries = sample.split(/[\r\n,]+/).map(s=>parseEntry(s.trim()));
    if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}
  showToast("サンプルデータを入力しました");
}
/* --- end 追加 --- */

function clearMemberHistories(){
  const confirmed = window.confirm("メンバーリストに含まれる全メンバーの履歴を一括で削除します。よろしいですか？");
  if(!confirmed) return;

  const cur = getRawValue() || "";
  const cleaned = cur.split(/[\r\n,]+/).map(s=>s.split('#')[0].trim()).filter(Boolean);
  setRawAndRefreshDisplay(cleaned.join("\n"));

  try{
    const entries = cleaned.map(s=>parseEntry(s));
    const mj = document.getElementById('membersJsonInput');
    if(mj) mj.value = JSON.stringify(entries);
  }catch(e){}

  // 履歴配列を再初期化して同期する（履歴をクリアしたら内部履歴も消す）
  if(cleaned.length === 0){
    shufflyHistory = [];
    currentHistoryIndex = -1;
  } else {
    const currentRaw = getRawValue().trim();
    shufflyHistory = [ currentRaw ];
    currentHistoryIndex = 0;
  }
  const histField = document.getElementById('historyJsonInput');
  if(histField) histField.value = shufflyHistory.length ? JSON.stringify(shufflyHistory) : "";

  // グループ表示は安全に非表示化（文言を消す）
  const gOut = document.getElementById('groupOutput');
  const sOut = document.getElementById('statsOutput');
  const gr = document.getElementById('groupRoundHint');
  if(gOut) gOut.value = "";
  if(sOut) sOut.value = "";
  if(gr) gr.textContent = '';

  updateParticipantCount();
  // pushToHistory() は不要（既に同期済み）
  showToast("履歴をクリアしました");
}

function togglePresentationMode(){
  try{
    const payload = {
      members_json: (()=>{ try { return JSON.parse(document.getElementById('membersJsonInput')?.value || '[]'); } catch(e){ return getRawValue() || ""; } })(),
      results_json: (()=>{ try { return JSON.parse(document.getElementById('resultsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('resultsJsonInput')?.value || ""; } })(),
      order_json: (()=>{ try { return JSON.parse(document.getElementById('orderJsonInput')?.value || '[]'); } catch(e){ return document.getElementById('orderOutput')?.value || ""; } })(),
      settings_json: (()=>{ try { return JSON.parse(document.getElementById('settingsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('settingsJsonInput')?.value || ""; } })(),
      history_json: document.getElementById('historyJsonInput')?.value || "",
      title: document.getElementById('shareEventTitle')?.value || document.title || ''
    };
    localStorage.setItem('presentation_shuffly_event', JSON.stringify(payload));
  }catch(e){
    console.warn('presentation payload store failed', e);
  }

  const presentationPath = '/events/show';
  const w = window.open(presentationPath, '_blank', 'noopener');
  if(!w) showToast("ポップアップがブロックされました。ポップアップを許可してください");

  try {
    if (typeof BroadcastChannel !== 'undefined') {
      const bc = new BroadcastChannel('shuffly_channel');
      setTimeout(()=> {
        try {
          const initPayload = {
            type: 'init',
            payload: payload,
            timestamp: Date.now()
          };
          bc.postMessage(initPayload);
        } catch(err){
          console.warn('BroadcastChannel post failed', err);
        } finally {
          try { bc.close(); } catch(e){}
        }
      }, 150);
    }
  } catch(e){
    console.warn('BroadcastChannel unavailable', e);
  }
}

function exportResults(){
  const groups = document.getElementById('groupOutput').value;
  const order = document.getElementById('orderOutput').value;
  const roles = document.getElementById('rolesOutput').value;
  const blob = new Blob([`グループ:\n${groups}\n\n順番:\n${order}\n\n役割:\n${roles}`], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = (document.getElementById('shareEventTitle').value || 'shuffly_result') + '.txt';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast("結果を出力しました");
}

function saveResults(){
  try{
    const membersRaw = getRawValue().trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    const entries = membersRaw.map(m=> parseEntry(m) );
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}

  if(!document.getElementById('resultsJsonInput').value){
    try { document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: {}, group_names: {} }); } catch(e){}
  }
  if(!document.getElementById('settingsJsonInput').value){
    try {
      document.getElementById('settingsJsonInput').value = JSON.stringify({
        roles: document.getElementById('rolesInput') ? document.getElementById('rolesInput').value : '',
        group_count: (document.getElementById('groupCount') ? document.getElementById('groupCount').value : '')
      });
    } catch(e){}
  }
  if(!document.getElementById('orderJsonInput').value){
    try {
      const orderText = document.getElementById('orderOutput').value || '';
      const names = orderText.split(/\r?\n/).map(l=>l.replace(/^\d+\.\s*/,'')).filter(Boolean);
      document.getElementById('orderJsonInput').value = JSON.stringify(names.map((n,i)=>({name:n, order:i+1})));
    }catch(e){}
  }
  if(!document.getElementById('historyJsonInput').value){
    try{ document.getElementById('historyJsonInput').value=JSON.stringify(shufflyHistory); }catch(e){}
  }

  const titleField = document.getElementById('hiddenEventTitle');
  if(titleField) titleField.value = document.getElementById('shareEventTitle').value;

  const payloadPreview = {
    members_json: document.getElementById('membersJsonInput').value,
    results_json: document.getElementById('resultsJsonInput').value,
    order_json: document.getElementById('orderJsonInput').value,
    settings_json: document.getElementById('settingsJsonInput').value,
    history_json: document.getElementById('historyJsonInput').value,
    title: document.getElementById('hiddenEventTitle') ? document.getElementById('hiddenEventTitle').value : ''
  };

  if(IS_SIGNED_IN){
    const form = document.getElementById('saveForm');
    if(form) {
      form.submit();
    } else {
      showToast("フォームが見つかりません");
    }
  } else {
    try {
      localStorage.setItem('pending_shuffly_event', JSON.stringify(payloadPreview));
      const loginUrl = "<%= new_user_session_path %>?redirect_to=" + encodeURIComponent(window.location.href);
      window.location.href = loginUrl;
    } catch(e){
      showToast("保存処理に失敗しました");
    }
  }
}

// --- 初期化: ページ読み込み時に状態を復元 / UI 初期化 ---
window.onload = () => {
  const histField = document.getElementById('historyJsonInput');
  if(histField && histField.value){
    try {
      shufflyHistory = JSON.parse(histField.value);
      currentHistoryIndex = shufflyHistory.length - 1;
      if (currentHistoryIndex >= 0) {
        const val = shufflyHistory[currentHistoryIndex];
        setRawAndRefreshDisplay(val);
      }
    } catch(e) {
      shufflyHistory=[]; currentHistoryIndex=-1;
    }
  } else {
    updateDisplayFromRaw();
  }
  updateParticipantCount();
  // 変更: 初回 push は現在の raw が空でない場合のみ行う（空状態を履歴に残さない）
  if(shufflyHistory.length === 0 && getRawValue().trim() !== "") pushToHistory();
  switchResultTab('groups');
  switchSettingsTab('groups');

  const sc = document.getElementById('statsContainer');
  const btn = document.getElementById('btn-toggle-stats');
  const textSpan = document.getElementById('btn-toggle-stats-text');
  const icon = document.getElementById('btn-toggle-stats-icon');
  if(sc && btn && textSpan && icon){
    if(statsCollapsed){
      sc.classList.add('hidden');
      textSpan.innerHTML = '<span class="text-sm text-blue-500">●</span> 統計情報';
      btn.setAttribute('aria-expanded', 'false');
      icon.src = ICON_EXPAND;
    } else {
      sc.classList.remove('hidden');
      textSpan.innerHTML = '<span class="text-sm text-blue-500">●</span> 統計情報';
      btn.setAttribute('aria-expanded', 'true');
      icon.src = ICON_COLLAPSE;
    }
  }

  const oc = document.getElementById('optionsContainer');
  const obtn = document.getElementById('btn-toggle-options');
  const otext = document.getElementById('btn-toggle-options-text');
  const oicon = document.getElementById('btn-toggle-options-icon');
  if(oc && obtn && otext && oicon){
    if(optionsCollapsed){
      oc.classList.add('hidden');
      // preserve dot styling by setting innerHTML so the dot keeps text-blue-500
      otext.innerHTML = '<span class="text-sm text-blue-500">●</span> グループ表示オプション';
      obtn.setAttribute('aria-expanded', 'false');
      oicon.src = ICON_EXPAND;
    } else {
      oc.classList.remove('hidden');
      otext.innerHTML = '<span class="text-sm text-blue-500">●</span> グループ表示オプション';
      obtn.setAttribute('aria-expanded', 'true');
      oicon.src = ICON_COLLAPSE;
    }
  }

  if(IS_SIGNED_IN){
    const pending = localStorage.getItem('pending_shuffly_event');
    if(pending){
      try {
        const p = JSON.parse(pending);
        if(p.members_json) document.getElementById('membersJsonInput').value = p.members_json;
        if(p.results_json) document.getElementById('resultsJsonInput').value = p.results_json;
        if(p.order_json) document.getElementById('orderJsonInput').value = p.order_json;
        if(p.settings_json) document.getElementById('settingsJsonInput').value = p.settings_json;
        if(p.history_json) document.getElementById('historyJsonInput').value = p.history_json;
        if(p.title && document.getElementById('hiddenEventTitle')) document.getElementById('hiddenEventTitle').value = p.title;
        const form = document.getElementById('saveForm');
        if(form){
          localStorage.removeItem('pending_shuffly_event');
          form.submit();
        }
      } catch(e){
        // 復元に失敗した場合は無視
      }
    }
  }
};

(function(){
  // 簡易バインドヘルパ: 存在する要素にだけイベントを登録
  function bindIf(id, evt, handler){
    const el = document.getElementById(id);
    if(el) el.addEventListener(evt, handler);
  }

  // 表示用 textarea の変更を内部 raw に反映
  bindIf('membersInput', 'input', ()=>{
    if(suppressDisplayInput) return;
    const disp = getDisplayValue();
    const raw = parseDisplayToRaw(disp);
    setRawValue(raw);
    updateParticipantCount();
    pushToHistory();
  });

  // 入力関連のイベント
  bindIf('groupCount', 'input', ()=>{ updateParticipantCount(); });
  bindIf('customGroupNames', 'input', ()=>{ updateParticipantCount(); });
  bindIf('rolesInput', 'input', ()=>{
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value=JSON.stringify({
      roles:document.getElementById('rolesInput').value,
      group_count: buildGroupIdsAndNames().groupCount
    });
  });

  // インポート / サンプルデータ / クリア
  bindIf('btn-trigger-import', 'click', (e)=>{ e.preventDefault(); triggerImport(); });
  bindIf('importFile', 'change', handleImportFile);
  bindIf('btn-insert-sample', 'click', (e)=>{ e.preventDefault(); insertSampleData(); });
  bindIf('btn-clear-history', 'click', (e)=>{ e.preventDefault(); clearMemberHistories(); });

  // タブ操作
  bindIf('tab-settings-groups', 'click', ()=>switchSettingsTab('groups'));
  bindIf('tab-settings-order', 'click', ()=>switchSettingsTab('order'));
  bindIf('tab-settings-roles', 'click', ()=>switchSettingsTab('roles'));

  bindIf('tab-groups', 'click', ()=>switchResultTab('groups'));
  bindIf('tab-order', 'click', ()=>switchResultTab('order'));
  bindIf('tab-roles', 'click', ()=>switchResultTab('roles'));

  // グループ表示オプションの変更（変更してもグループ分け実行前は結果反映しない）
  bindIf('showGroupLabel', 'change', ()=>{ if(groupsAssigned){ showGroups(); showStats(); } });
  bindIf('showGroupCount', 'change', ()=>{ if(groupsAssigned){ showGroups(); showStats(); } });
  bindIf('breakMemberLine', 'change', ()=>{ if(groupsAssigned) showGroups(); });
  bindIf('separatorSelect', 'change', ()=>{ if(groupsAssigned){ showGroups(); showStats(); } });
  bindIf('groupSeparatorSelect', 'change', ()=>{ if(groupsAssigned){ showGroups(); showStats(); } });

  // コピー / ナビ操作
  bindIf('btn-copy-groupoutput', 'click', (e)=>{ e.preventDefault(); copyGroupOutput(); });
  bindIf('btn-copy-orderoutput', (e)=>{ e.preventDefault(); copyOrderOutput(); });
  bindIf('btn-copy-rolesoutput', (e)=>{ e.preventDefault(); copyRolesOutput(); });

  // 統計表示トグル
  bindIf('btn-toggle-stats', 'click', (e)=>{
    if(e) e.preventDefault();
    const sc = document.getElementById('statsContainer');
    const btn = document.getElementById('btn-toggle-stats');
    const textSpan = document.getElementById('btn-toggle-stats-text');
    const icon = document.getElementById('btn-toggle-stats-icon');
    if(!sc || !btn || !textSpan || !icon) return;
    sc.classList.toggle('hidden');
    const expanded = !sc.classList.contains('hidden');
    statsCollapsed = sc.classList.contains('hidden');
    textSpan.innerHTML = '<span class="text-sm text-blue-500">●</span> 統計情報';
    btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
    icon.src = expanded ? ICON_COLLAPSE : ICON_EXPAND;
    if(!statsCollapsed) showStats();
  });

  // グループ表示オプション折りたたみトグル（開閉自体は可能だが、結果表示はグループ分け実行後のみ反映）
  bindIf('btn-toggle-options', 'click', (e)=>{
    if(e) e.preventDefault();
    const oc = document.getElementById('optionsContainer');
    const btn = document.getElementById('btn-toggle-options');
    const textSpan = document.getElementById('btn-toggle-options-text');
    const icon = document.getElementById('btn-toggle-options-icon');
    if(!oc || !btn || !textSpan || !icon) return;
    oc.classList.toggle('hidden');
    const expanded = !oc.classList.contains('hidden');
    optionsCollapsed = oc.classList.contains('hidden');
    // preserve dot styling by setting innerHTML so the dot keeps text-blue-500
    textSpan.innerHTML = '<span class="text-sm text-blue-500">●</span> グループ表示オプション';
    btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
    icon.src = expanded ? ICON_COLLAPSE : ICON_EXPAND;
    // 変更点：グループ分け実行が行われていない限り、開閉時に groupOutput を更新しない
    if(!optionsCollapsed && groupsAssigned) { showGroups(); showStats(); }
  });

  // 結果の履歴移動
  bindIf('btn-prev-group', 'click', (e)=>{
    if(e) e.preventDefault();
    const firstIndex = findFirstGroupHistoryIndex();
    if(currentHistoryIndex <= firstIndex){
      showToast("これ以上戻れません");
      return;
    }
    undoHistory();
  });
  bindIf('btn-next-group', 'click', (e)=>{
    if(e) e.preventDefault();
    if(currentHistoryIndex >= shufflyHistory.length-1){
      showToast("これ以上進めません");
      return;
    }
    redoHistory();
  });

  // 共有 / エクスポート / 保存
  bindIf('btn-toggle-presentation', 'click', (e)=>{ if(e) e.preventDefault(); togglePresentationMode(); });
  bindIf('btn-export-results', 'click', (e)=>{ if(e) e.preventDefault(); exportResults(); });
  bindIf('btn-save-results', 'click', (e)=>{ if(e) e.preventDefault(); saveResults(); });

  // 設定パネル内の実行ボタンに処理を紐付け
  const gAct = document.getElementById('settings-action-groups');
  if (gAct) {
    const btns = gAct.querySelectorAll('button, a[role="button"], a');
    if (btns[0]) btns[0].addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignGroups(); });
  }
  const oAct = document.getElementById('settings-action-order');
  if (oAct) {
    const b = oAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignOrder(); });
  }
  const rAct = document.getElementById('settings-action-roles');
  if (rAct) {
    const b = rAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignRoles(); });
  }
})();
</script>