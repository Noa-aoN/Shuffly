<%# filepath: /Users/n/workspace/Shuffly/app/views/events/new.html.erb %>
<div class="max-w-6xl mx-auto px-6 pt-2 pb-10">
  <h1 class="text-3xl font-bold mb-8"><%= @event.title.presence || "イベント作成" %></h1>

  <div class="flex flex-col gap-6">

    <!-- ① メンバーを追加 -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">1</div>
        <h2 class="text-lg font-semibold">メンバーを入力</h2>
      </div>

      <label class="block text-sm font-medium mb-2">メンバー名リスト（改行またはカンマ区切り）</label>

      <!-- hidden raw data textarea (機能上のデータはここに保持) -->
      <textarea id="membersRaw" rows="10" class="hidden" style="display:none;"><%= begin
        members = @event.members_json.present? ? JSON.parse(@event.members_json) : []
        members.map do |m|
          if m.is_a?(Hash)
            name = m["name"]
            hist = m["history"]&.join("") || ""
            "#{name}#{hist}"
          else
            m
          end
        end.join("\n")
      rescue JSON::ParserError
        ""
      end %></textarea>

      <!-- visible textarea for user (表示はフォーマットして見やすくする) -->
      <textarea id="membersInput" rows="10" class="w-full border rounded-md px-3 py-2" placeholder="例：メンバー1, メンバー2, ..."></textarea>
      <p class="text-xs text-gray-500 mt-0 mb-4">ユニークなメンバー名を入力してください。</p>

      <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
        <a href="#" id="btn-trigger-import" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">テキスト/CSVから入力</a>
        <input id="importFile" type="file" accept=".txt,.csv" class="hidden">
        <a href="#" id="btn-paste-clipboard" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">クリップボードから入力</a>
        <a href="#" id="btn-clear-history" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">履歴をクリア</a>
      </div>
    </div>

    <!-- ② 設定を選択（タブ切替: グループ / 順番 / 役割） -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">2</div>
        <h2 class="text-lg font-semibold">設定 / 実行</h2>
      </div>

      <!-- タブボタン（カード名の下・中央配置・下線バー風） -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-settings-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">グループ設定</button>
        <button id="tab-settings-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">順番設定</button>
        <button id="tab-settings-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">役割設定</button>
      </div>

      <!-- グループパネル -->
      <div id="panel-settings-groups" class="settings-panel">
        <div class="mb-4">
          <label class="block font-medium mb-1">グループ分けオプション</label>
          <div class="flex flex-col gap-3 mb-2">
            <div>
              <label class="text-xs text-gray-600">グループ数</label>
              <input id="groupCount" type="number" min="1" max="26" value="<%= @event.group_count.presence || 3 %>" class="mt-1 w-full border rounded px-2 py-1 mb-1">
            </div>
            <div>
              <label class="text-xs text-gray-600">グループ名（任意：改行またはカンマ区切り）</label>
              <textarea id="customGroupNames" rows="2" class="w-full border rounded px-2 py-1" placeholder="例：グループA, グループB, ..."></textarea>
              <p class="text-xs text-gray-500 mb-1">グループ名を入力すると、その数が優先してグループ数に反映されます。</p>
            </div>
          </div>

          <div>
            <label class="text-xs text-gray-600">分散固定メンバー（任意：改行またはカンマ区切り）</label>
            <textarea id="fixedMembersInput" rows="2" class="w-full border rounded px-2 py-1" placeholder="例：メンバー3, メンバー5, ..."></textarea>
            <p class="text-xs text-gray-500 mb-1">入力されたメンバーはグループ分け実行時に可能な限り分散し、グループに固定します。</p>
          </div>

          <div id="groupSizeHint" class="text-xs text-gray-500 mt-2"></div>
        </div>
      </div>

      <!-- 順番パネル -->
      <div id="panel-settings-order" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">順番決めオプション</label>

          <div class="mb-2">
            <label class="text-xs text-gray-600">順番固定メンバー（任意：改行またはカンマ区切り）</label>
            <textarea id="fixedOrderInput" rows="3" class="w-full border rounded px-2 py-1" placeholder="例：1:メンバー3, 5:メンバー1, ..."></textarea>
            <p class="text-xs text-gray-500 mt-1">「固定する番号:メンバー名」を入力してください。順番決め実行時にその番号に対応するメンバーが固定され、残りのメンバーはランダムに割り当てられます。</p>
          </div>

          <p class="text-xs text-gray-500 mt-2">固定を使わない場合は空欄のまま「順番決め実行」を押すと全員の順番がランダムに決まります。</p>
        </div>
      </div>

      <!-- 役割パネル（オプションは除去。役割は常にランダムかつ一意に割り当てられます） -->
      <div id="panel-settings-roles" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">役割決めオプション</label>
          <label class="text-xs text-gray-600">役割名（改行またはカンマ区切り）</label>
          <textarea id="rolesInput" rows="3" class="w-full border rounded px-2 py-1" placeholder="例：司会, 書記, ..."><%= @event.setting_json["roles"] rescue "" %></textarea>

          <p class="text-xs text-gray-500 mt-2">複数の役割をカンマ区切りで入力してください。役割の割り当ては常にランダムに行われ、各役割は可能な限り異なるメンバーに一意に割り当てられます。</p>
        </div>
      </div>

      <!-- ボタン群（パネル毎に表示） -->
      <!-- グループ用アクション -->
      <div id="settings-action-groups" class="mt-4">
        <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: 'グループ分け実行',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>

      <!-- 順番用アクション -->
      <div id="settings-action-order" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: '順番決め実行',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>

      <!-- 役割用アクション -->
      <div id="settings-action-roles" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: '役割決め実行',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>
    </div>

    <!-- ③ 結果 -->
    <div id="resultsCard" class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start justify-between mb-4">
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">3</div>
          <h2 class="text-lg font-semibold">結果を表示</h2>
        </div>
      </div>

      <!-- タブボタン（カード名の下・中央配置・下線バー風） -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">グループ表示</button>
        <button id="tab-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">順番表示</button>
        <button id="tab-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">役割表示</button>
      </div>

      <!-- グループ表示＋統計（デフォルト表示） -->
      <div id="panel-groups" class="result-panel">
        <h3 class="font-medium mb-2">グループ表示</h3>

        <div class="mb-2">
          <div class="flex flex-col sm:flex-row sm:items-center gap-2">
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="showGroupLabel" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">グループ名表示</span>
            </label>
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="showGroupCount" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">グループ人数表示</span>
            </label>
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="breakMemberLine" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">メンバーを改行表示</span>
            </label>
          </div>

          <div class="mt-2 flex flex-col sm:flex-row sm:items-center gap-3">
            <div>
              <label class="text-sm mr-2">メンバーの区切り方:</label>
              <select id="separatorSelect" class="border rounded-md px-2 py-1 mt-1">
                <option value=" " >スペース</option>
                <option value="," selected>カンマ</option>
                <option value="\\n">改行</option>
                <option value="  ">ダブルスペース</option>
                <option value="\\t">タブ</option>
              </select>
            </div>

            <div>
              <label class="text-sm mr-2">グループの区切り方:</label>
              <select id="groupSeparatorSelect" class="border rounded-md px-2 py-1 mt-1">
                <option value="space">スペース</option>
                <option value="none" selected>なし</option>
                <option value="line">線</option>
                <option value="wave">波線</option>
              </select>
            </div>
          </div>
        </div>

        <!-- 結果表示フォーム色を薄いグレー系に変更 -->
        <!-- 初期は空。グループ分け実行ボタン押下後に初回表示される -->
        <textarea id="groupOutput" rows="10" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full mb-4 text-lg"></textarea>

        <!-- 統計情報（折りたたみ可能・デフォルトは折りたたみ） -->
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-medium"><a href="#" id="btn-toggle-stats" class="hover:underline">統計情報を表示</a></h3>
        </div>
        <div id="statsContainer" class="hidden">
          <textarea id="statsOutput" rows="10" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-sm mb-3"></textarea>
        </div>

        <!-- クリップボードコピー / 履歴移動（リンクスタイル） -->
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <a href="#" id="btn-prev-group" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">前回のグループ分けへ</a>
          <a href="#" id="btn-next-group" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">次回のグループ分けへ</a>
          <a href="#" id="btn-copy-groupoutput" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>

      </div>

      <!-- 順番表示パネル -->
      <div id="panel-order" class="result-panel hidden">
        <h3 class="font-medium mb-2">順番表示</h3>
        <textarea id="orderOutput" rows="10" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-orderoutput" class="text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>

      <!-- 役割表示パネル -->
      <div id="panel-roles" class="result-panel hidden">
        <h3 class="font-medium mb-2">役割表示</h3>
        <textarea id="rolesOutput" rows="10" readonly class="bg-gray-50 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-rolesoutput" class="text-sm text-blue-600 hover:underline">クリップボードにコピー</a>
        </div>
      </div>
    </div>

    <!-- ④ 出力 -->
    <div class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">4</div>
        <h2 class="text-lg font-semibold">共有 / 出力 / 保存</h2>
      </div>

      <label class="block text-sm font-medium mb-2">イベントタイトル（任意）</label>
      <!-- イベントタイトルフォームの色を白系に戻す -->
      <input id="shareEventTitle" type="text" value="<%= @event.title %>" class="w-full border rounded px-3 py-2 mb-3 bg-white" placeholder="例：〇〇イベント">

      <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
        <%= render 'shared/button',
              f: nil,
              button_text: '画面共有表示',
              id: 'btn-toggle-presentation',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'テキスト出力',
              id: 'btn-export-results',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'イベント保存',
              id: 'btn-save-results',
              path: '#',
              variant: 'primary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
      </div>

      <p class="text-xs text-gray-500">イベント保存にはログインが必要です。</p>

      <!-- hidden 保存フォーム（submit は saveResults() が制御） -->
      <%= form_with(model: @event, local: true, html: { id: 'saveForm', style: 'display:none' }) do |f| %>
        <%= f.hidden_field :members_json, id: 'membersJsonInput' %>
        <%= f.hidden_field :member_results_json, id: 'resultsJsonInput' %>
        <%= f.hidden_field :member_order_json, id: 'orderJsonInput' %>
        <%= f.hidden_field :setting_json, id: 'settingsJsonInput' %>
        <%= f.hidden_field :history_json, id: 'historyJsonInput' %>
        <%= f.hidden_field :title, value: @event.title, name: 'event[title]', id: 'hiddenEventTitle' %>
      <% end %>
    </div>

  </div>

  <div id="toast" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-black text-white px-4 py-2 rounded opacity-0 transition-opacity"></div>
</div>

<script>
let shufflyHistory = [], currentHistoryIndex = -1;
const IS_SIGNED_IN = <%= user_signed_in? ? 'true' : 'false' %>;
let statsCollapsed = true; // 統計情報はデフォルトで折りたたみ

// --- helper functions (existing) ---
function clampGroupCount(v){
  return Math.min(Math.max(parseInt(v) || 1, 1), 26);
}
function parseEntry(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  return {name, history: hist};
}
function getCurrentRound(entries){
  let max=0;
  for(const e of entries) for(const h of e.history) {
    const m = h.match(/^#(\d+)/);
    if(m) max=Math.max(max, parseInt(m[1]));
  }
  return max+1;
}
function getCoOccurrenceMap(entries, ignoreLast=true){
  const map={}, histories={};
  for(const e of entries) histories[e.name]=ignoreLast?e.history.slice(0,-1):e.history;
  for(const e of entries) map[e.name]={};
  for(const a of entries){
    for(const b of entries){
      if(a.name===b.name) continue;
      const overlap=histories[a.name].filter(h=>histories[b.name].includes(h));
      map[a.name][b.name]=overlap.length;
    }
  }
  return map;
}

// 共通: グループID(A,B,...)と表示名の決定
function buildGroupIdsAndNames(){
  const groupCountInputEl = document.getElementById('groupCount');
  const inputGroupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  const customNamesEl = document.getElementById('customGroupNames');
  const customNames = (customNamesEl ? customNamesEl.value : "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);

  let groupCount;
  let ids = [];
  let displayNames = [];

  if(customNames.length > 0){
    groupCount = Math.min(customNames.length, 26);
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = customNames.slice(0, groupCount);
  } else {
    groupCount = inputGroupCount;
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = ids.slice();
  }

  const idToName = {};
  ids.forEach((id, idx) => idToName[id] = displayNames[idx] || id);
  return { ids, displayNames, idToName, groupCount };
}

// --- New helpers for display-only formatted history ---
let suppressDisplayInput = false;

function getRawValue(){ return (document.getElementById('membersRaw') || {value:''}).value || ""; }
function setRawValue(v){ const el = document.getElementById('membersRaw'); if(el) el.value = v; }

function getDisplayValue(){ return (document.getElementById('membersInput') || {value:''}).value || ""; }
function setDisplayValue(v){ const el = document.getElementById('membersInput'); if(el) el.value = v; }

function formatEntryForDisplay(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  const { idToName } = buildGroupIdsAndNames();
  const formattedHist = hist.map(h=>{
    const m=h.match(/^#(\d+)([A-Z])$/);
    if(m){
      const num=m[1], id=m[2];
      const gname = idToName[id] || id;
      return ` [ ${num}回目：${gname} ]`;
    }
    return h;
  }).join('');
  return `${name}${formattedHist}`;
}

function updateDisplayFromRaw(){
  const raw = getRawValue();
  const lines = raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const formatted = lines.map(formatEntryForDisplay).join("\n");
  suppressDisplayInput = true;
  setDisplayValue(formatted);
  setTimeout(()=>{ suppressDisplayInput = false; }, 0);
}

function parseDisplayToRaw(displayText){
  const { idToName } = buildGroupIdsAndNames();
  const nameToId = {};
  for(const k in idToName) nameToId[idToName[k]] = k;

  const lines = displayText.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const rawLines = lines.map(line=>{
    const parts = line.split('#').filter(Boolean);
    if(parts.length === 0) return "";
    const base = parts[0].trim();
    const tokens = parts.slice(1);
    const rawTokens = tokens.map(tok=>{
      const mRaw = tok.match(/^(\d+)([A-Z])$/);
      if(mRaw) return `#${mRaw[1]}${mRaw[2]}`;
      const m = tok.match(/^(\d+)\s*巡目\s*[:：]\s*(.+)$/);
      if(m){
        const num = m[1];
        const gname = m[2].trim();
        let id = nameToId[gname];
        if(!id){
          const stripped = gname.replace(/^グループ\s*/i,'').trim();
          id = nameToId[stripped];
        }
        if(id) return `#${num}${id}`;
        return `#${num}`;
      }
      return `#${tok.replace(/^#?/,'')}`;
    }).filter(Boolean);
    return base + rawTokens.join('');
  }).filter(Boolean);
  return rawLines.join("\n");
}

function setRawAndRefreshDisplay(rawText){
  setRawValue(rawText);
  updateDisplayFromRaw();
}

// --- Adjusted core functions to use raw storage (membersRaw) for processing ---
function assignGroups(){
  let raw = getRawValue().trim();
  let rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let entries = rawList.map(parseEntry);
  const round=getCurrentRound(entries);

  const { ids: groupIds, idToName, groupCount } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  const coMap=getCoOccurrenceMap(entries);

  const fixedRaw = (document.getElementById('fixedMembersInput').value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedSet = new Set(fixedRaw);
  const fixedEntries = entries.filter(e=>fixedSet.has(e.name));
  const otherEntries = entries.filter(e=>!fixedSet.has(e.name));

  // helper: pick random element from array
  function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // assign fixed entries but randomize among empty/min candidates to avoid left-bias
  for(const p of fixedEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    if(emptyGroups.length>0){
      const chosen = pickRandom(emptyGroups);
      groups[chosen].push(p);
    } else {
      const minSize = Math.min(...groupIds.map(g=>groups[g].length));
      const candidates = groupIds.filter(g=>groups[g].length===minSize);
      const chosen = pickRandom(candidates);
      groups[chosen].push(p);
    }
  }

  for(const p of otherEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    if(emptyGroups.length>0){
      // when there are multiple empty groups, pick randomly among them
      const chosen = pickRandom(emptyGroups);
      groups[chosen].push(p);
      continue;
    }

    const minSize=Math.min(...groupIds.map(g=>groups[g].length));
    const candidates=groupIds.filter(g=>groups[g].length===minSize);

    // compute co-occurrence score (mk) for each candidate and choose among ties randomly
    let minMK=Infinity;
    const scores=[];
    for(const g of candidates){
      const mk=groups[g].reduce((acc,q)=>acc+(coMap[p.name][q.name]||0),0);
      scores.push({g, mk});
      if(mk<minMK) minMK=mk;
    }
    const tied = scores.filter(s=>s.mk===minMK).map(s=>s.g);
    const selected = pickRandom(tied);
    groups[selected].push(p);
  }

  const rolesForGroups = document.getElementById('rolesInput').value.split(',').map(r=>r.trim()).filter(Boolean);
  if(rolesForGroups.length>0){
    for(const g of groupIds){
      const members=groups[g];
      members.forEach((m,i)=>m.role=rolesForGroups[i%rolesForGroups.length]);
    }
  }

  const updated=groupIds.flatMap(g=>groups[g].map(e=>`${e.name}${e.history.join('')}#${round}${g}`));
  setRawAndRefreshDisplay(updated.join("\n"));

  try{
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: groups, group_names: buildGroupIdsAndNames().idToName });
    document.getElementById('settingsJsonInput').value = JSON.stringify({
      roles: document.getElementById('rolesInput').value,
      group_count: groupCount,
      custom_group_names: (document.getElementById('customGroupNames').value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean)
    });
  }catch(e){
    console.warn("JSON シリアライズ失敗:", e);
  }

  updateParticipantCount(); showGroups(); showStats(); pushToHistory();
  switchResultTab('groups');
}

function assignOrder(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length === 0){
    document.getElementById('orderOutput').value = "";
    if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = "[]";
    showToast("参加者がいません");
    return;
  }

  const fixedRaw = (document.getElementById('fixedOrderInput')?.value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedMap = {};
  const invalids = [];
  for(const line of fixedRaw){
    if(!line) continue;
    const m = line.match(/^(\d+)\s*[:=]\s*(.+)$/) || line.match(/^(\d+)\s+(.+)$/);
    if(m){
      const pos = parseInt(m[1],10);
      const name = m[2].trim();
      if(pos >= 1 && pos <= members.length){
        fixedMap[pos] = name;
      } else {
        invalids.push(line);
      }
    } else {
      invalids.push(line);
    }
  }

  const namesSet = new Set(members);
  const assignedFixedNames = new Set();
  const invalidNameEntries = [];
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    const name = fixedMap[pos];
    if(!namesSet.has(name)){
      invalidNameEntries.push(`${pos}: ${name}`);
      delete fixedMap[pos];
    } else {
      assignedFixedNames.add(name);
    }
  }

  if(invalids.length>0 || invalidNameEntries.length>0){
    const msgs = [];
    if(invalids.length>0) msgs.push("固定指定の書式が不正な行があります");
    if(invalidNameEntries.length>0) msgs.push("参加者に存在しない名前の固定指定があります");
    showToast(msgs.join('、') + "（無視されます）");
  }

  const pool = members.filter(m=>!assignedFixedNames.has(m));
  for(let i=pool.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [pool[i], pool[j]]=[pool[j], pool[i]];
  }

  const result = Array(members.length).fill(null);
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    result[pos-1] = fixedMap[pos];
  }

  let poolIdx = 0;
  for(let i=0;i<result.length;i++){
    if(result[i] === null){
      result[i] = pool[poolIdx++] || "";
    }
  }

  const lines = result.map((name, idx) => `${idx+1}. ${name}`);
  document.getElementById('orderOutput').value = lines.join("\n");

  const orderJson = result.map((name, idx) => ({ name, order: idx+1 }));
  if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = JSON.stringify(orderJson);

  showToast("順番を割り当てました");
  switchResultTab('order');
}

function assignRoles(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length===0){ showToast("参加者がいません"); return; }

  const roles = document.getElementById('rolesInput').value.split(',').map(r=>r.trim()).filter(Boolean);
  if(roles.length===0){ showToast("役割が未入力です"); return; }

  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]]=[arr[j], arr[i]];
    }
  }

  const pool = members.slice();
  shuffleArray(pool);

  const assignments = [];
  for(let i=0;i<roles.length && i<pool.length;i++){
    assignments.push({ name: pool[i], role: roles[i] });
  }
  const assignedNames = new Set(assignments.map(a=>a.name));
  for(const m of members){
    if(!assignedNames.has(m)) assignments.push({ name: m, role: null });
  }

  const displayLines = assignments.map(a => a.role ? `${a.name}: ${a.role}` : `${a.name}: `);
  document.getElementById('rolesOutput').value = displayLines.join("\n");

  try {
    const settingsField = document.getElementById('settingsJsonInput');
    let settings = {};
    if(settingsField && settingsField.value) {
      try { settings = JSON.parse(settingsField.value); } catch(e){ settings = {}; }
    }
    settings.role_assignments = assignments.map(a => ({ name: a.name, role: a.role }));
    if(settingsField) settingsField.value = JSON.stringify(settings);
  } catch(e){
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value = JSON.stringify({ role_assignments: assignments.map(a=>({ name:a.name, role: a.role })) });
  }

  showToast("役割を割り当てました");
  switchResultTab('roles');
}

function showGroups(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries = rawList.map(parseEntry);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)) {
      let empty = groupIds.find(g=>groups[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groups[g].length));
        id = groupIds.find(g=>groups[g].length===minSize);
      }
    }
    groups[id].push(e.name);
  }

  // separator support: space, comma (default), double-space, tab, newline
  const sepVal = document.getElementById('separatorSelect').value;
  const memberSep = sepVal==='\\t' ? '\t' : (sepVal==='\\n' ? '\n' : sepVal);
  const showLabel=document.getElementById('showGroupLabel').checked;
  const showCount=document.getElementById('showGroupCount') ? document.getElementById('showGroupCount').checked : true;
  const breakMemberLine = document.getElementById('breakMemberLine') ? document.getElementById('breakMemberLine').checked : true;
  const groupSepVal = document.getElementById('groupSeparatorSelect') ? document.getElementById('groupSeparatorSelect').value : 'space';

  let groupSep = '\n\n'; // default to previous behaviour
  if(groupSepVal === 'none') groupSep = '\n'; // minimal: single newline
  else if(groupSepVal === 'space') groupSep = '\n\n';
  else if(groupSepVal === 'line') groupSep = '\n────────\n';
  else if(groupSepVal === 'wave') groupSep = '\n〜〜〜〜〜〜〜\n';

  const parts = [];
  for(const id of groupIds){
    const members=groups[id];
    const label = idToName[id] || id;
    let block = '';
    if(showLabel){
      const countText = showCount ? `（${members.length}人）` : '';
      // When breakMemberLine is true, keep newline after label; otherwise keep header and members inline
      block += breakMemberLine ? `${label}${countText}：\n` : `${label}${countText}： `;
    }
    block += members.join(memberSep);
    parts.push(block);
  }

  const display = parts.join(groupSep);
  document.getElementById('groupOutput').value=display.trim();
}

function showStats(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries=rawList.map(parseEntry);
  const coMap=getCoOccurrenceMap(entries,true);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groupMap=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)){
      let empty = groupIds.find(g=>groupMap[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groupMap[g].length));
        id = groupIds.find(g=>groupMap[g].length===minSize);
      }
    }
    groupMap[id].push(e.name);
  }

  const lines=[];
  for(const id of groupIds){
    const members=groupMap[id];
    let total=0;
    const memberLines = [];
    for(const m of members){
      const mk=members.reduce((sum,other)=>sum+(m!==other?(coMap[m][other]||0):0),0);
      memberLines.push(`${m}：被り経験数＝${mk}`);
      total+=mk;
    }
    // group header first, then member lines (average calculated above)
    lines.push(`${idToName[id] ? `グループ ${idToName[id]}` : `グループ ${id}`}（被り経験数平均＝${members.length? (total/members.length).toFixed(2):0}）：`);
    lines.push(...memberLines);
    lines.push('');
  }
  document.getElementById('statsOutput').value=lines.join("\n");
}

function updateParticipantCount(){
  const raw = getRawValue().trim();
  const count = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean).length : 0;
  const span=document.getElementById('groupSizeHint');
  const { groupCount } = buildGroupIdsAndNames();
  if(!groupCount||count===0){ if(span) span.textContent=''; return;}
  const min=Math.floor(count/groupCount), max=Math.ceil(count/groupCount);
  if(span) span.textContent=min===max?`（1グループあたり${min}人）`:`（1グループあたり${min}〜${max}人）`;
}

function copyGroupOutput(){ navigator.clipboard.writeText(document.getElementById('groupOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyOrderOutput(){ navigator.clipboard.writeText(document.getElementById('orderOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }
function copyRolesOutput(){ navigator.clipboard.writeText(document.getElementById('rolesOutput').value).then(()=>showToast("コピーしました！")).catch(()=>showToast("コピーに失敗しました")); }

function showToast(msg){
  const toast=document.getElementById('toast');
  toast.textContent=msg;
  toast.classList.remove("opacity-0");
  setTimeout(()=>toast.classList.add("opacity-0"),1200);
}

function pushToHistory(){
  const text = getRawValue();
  if(currentHistoryIndex>=0 && shufflyHistory[currentHistoryIndex]===text) return;
  shufflyHistory = shufflyHistory.slice(0,currentHistoryIndex+1);
  shufflyHistory.push(text);
  currentHistoryIndex++;
  const histField = document.getElementById('historyJsonInput');
  if(histField) histField.value=JSON.stringify(shufflyHistory);
}

function undoHistory(){
  if(currentHistoryIndex>0){
    currentHistoryIndex--;
    const val = shufflyHistory[currentHistoryIndex];
    setRawAndRefreshDisplay(val);
    updateParticipantCount();
    showGroups();
    showStats();
    try{
      const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
      if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    }catch(e){}
    showToast("1ステップ戻しました");
    switchResultTab('groups');
  } else showToast("これ以上戻れません");
}

function redoHistory(){
  if(currentHistoryIndex<shufflyHistory.length-1){
    currentHistoryIndex++;
    const val = shufflyHistory[currentHistoryIndex];
    setRawAndRefreshDisplay(val);
    updateParticipantCount();
    showGroups();
    showStats();
    try{
      const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
      if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    }catch(e){}
    showToast("1ステップ進めました");
    switchResultTab('groups');
  } else showToast("これ以上進めません");
}

// 結果タブ切替
function switchResultTab(name){
  document.querySelectorAll('.result-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-groups, #tab-order, #tab-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-groups').classList.remove('hidden'); const el=document.getElementById('tab-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-order').classList.remove('hidden'); const el=document.getElementById('tab-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-roles').classList.remove('hidden'); const el=document.getElementById('tab-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
}

// 設定タブ切替（新規）
function switchSettingsTab(name){
  document.querySelectorAll('.settings-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-settings-groups, #tab-settings-order, #tab-settings-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-settings-groups').classList.remove('hidden'); const el=document.getElementById('tab-settings-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-settings-order').classList.remove('hidden'); const el=document.getElementById('tab-settings-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-settings-roles').classList.remove('hidden'); const el=document.getElementById('tab-settings-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }

  const gAct = document.getElementById('settings-action-groups');
  const oAct = document.getElementById('settings-action-order');
  const rAct = document.getElementById('settings-action-roles');
  if(gAct) gAct.classList.add('hidden');
  if(oAct) oAct.classList.add('hidden');
  if(rAct) rAct.classList.add('hidden');
  if(name==='groups' && gAct) gAct.classList.remove('hidden');
  if(name==='order' && oAct) oAct.classList.remove('hidden');
  if(name==='roles' && rAct) rAct.classList.remove('hidden');
}

// インポート補助
function triggerImport(){ const f = document.getElementById('importFile'); if(f) f.click(); }
function handleImportFile(e){
  const file = e.target.files ? e.target.files[0] : null;
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const text = ev.target.result;
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + text.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("ファイルをインポートしました");
  };
  reader.readAsText(file, 'utf-8');
}
function pasteFromClipboard(){
  navigator.clipboard.readText().then(txt=>{
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + txt.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("クリップボードから貼り付けました");
  }).catch(()=>showToast("クリップボードにアクセスできません"));
}

// 履歴クリア（メンバー名以降を一括削除）
function clearMemberHistories(){
  const rawEl = getRawValue();
  if(rawEl === undefined) return;
  const confirmed = window.confirm("メンバー名リストに含まれる全メンバーの履歴を一括で削除します。よろしいですか？");
  if(!confirmed) return;

  const cur = getRawValue() || "";
  const cleaned = cur.split(/[\r\n,]+/).map(s=>s.split('#')[0].trim()).filter(Boolean);
  setRawAndRefreshDisplay(cleaned.join("\n"));
  updateParticipantCount();
  pushToHistory();
  showToast("履歴をクリアしました");
}

function togglePresentationMode(){
  try{
    const payload = {
      members_json: (()=>{ try { return JSON.parse(document.getElementById('membersJsonInput')?.value || '[]'); } catch(e){ return getRawValue() || ""; } })(),
      results_json: (()=>{ try { return JSON.parse(document.getElementById('resultsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('resultsJsonInput')?.value || ""; } })(),
      order_json: (()=>{ try { return JSON.parse(document.getElementById('orderJsonInput')?.value || '[]'); } catch(e){ return document.getElementById('orderOutput')?.value || ""; } })(),
      settings_json: (()=>{ try { return JSON.parse(document.getElementById('settingsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('settingsJsonInput')?.value || ""; } })(),
      history_json: document.getElementById('historyJsonInput')?.value || "",
      title: document.getElementById('shareEventTitle')?.value || document.title || ''
    };
    localStorage.setItem('presentation_shuffly_event', JSON.stringify(payload));
  }catch(e){
    console.warn('presentation payload store failed', e);
  }

  const presentationPath = '/events/show';
  const w = window.open(presentationPath, '_blank', 'noopener');
  if(!w) showToast("ポップアップがブロックされました。ポップアップを許可してください");
}

function exportResults(){
  const groups = document.getElementById('groupOutput').value;
  const order = document.getElementById('orderOutput').value;
  const roles = document.getElementById('rolesOutput').value;
  const blob = new Blob([`グループ:\n${groups}\n\n順番:\n${order}\n\n役割:\n${roles}`], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = (document.getElementById('shareEventTitle').value || 'shuffly_result') + '.txt';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast("結果を出力しました");
}

function saveResults(){
  try{
    const membersRaw = getRawValue().trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    const entries = membersRaw.map(m=> parseEntry(m) );
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}

  if(!document.getElementById('resultsJsonInput').value){
    try { document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: {}, group_names: {} }); } catch(e){}
  }
  if(!document.getElementById('settingsJsonInput').value){
    try {
      document.getElementById('settingsJsonInput').value = JSON.stringify({
        roles: document.getElementById('rolesInput') ? document.getElementById('rolesInput').value : '',
        group_count: (document.getElementById('groupCount') ? document.getElementById('groupCount').value : '')
      });
    } catch(e){}
  }
  if(!document.getElementById('orderJsonInput').value){
    try {
      const orderText = document.getElementById('orderOutput').value || '';
      const names = orderText.split(/\r?\n/).map(l=>l.replace(/^\d+\.\s*/,'')).filter(Boolean);
      document.getElementById('orderJsonInput').value = JSON.stringify(names.map((n,i)=>({name:n, order:i+1})));
    }catch(e){}
  }
  if(!document.getElementById('historyJsonInput').value){
    try{ document.getElementById('historyJsonInput').value=JSON.stringify(shufflyHistory); }catch(e){}
  }

  const titleField = document.getElementById('hiddenEventTitle');
  if(titleField) titleField.value = document.getElementById('shareEventTitle').value;

  const payloadPreview = {
    members_json: document.getElementById('membersJsonInput').value,
    results_json: document.getElementById('resultsJsonInput').value,
    order_json: document.getElementById('orderJsonInput').value,
    settings_json: document.getElementById('settingsJsonInput').value,
    history_json: document.getElementById('historyJsonInput').value,
    title: document.getElementById('hiddenEventTitle') ? document.getElementById('hiddenEventTitle').value : ''
  };

  if(IS_SIGNED_IN){
    const form = document.getElementById('saveForm');
    if(form) {
      form.submit();
    } else {
      showToast("フォームが見つかりません");
    }
  } else {
    try {
      localStorage.setItem('pending_shuffly_event', JSON.stringify(payloadPreview));
      const loginUrl = "<%= new_user_session_path %>?redirect_to=" + encodeURIComponent(window.location.href);
      window.location.href = loginUrl;
    } catch(e){
      showToast("保存処理に失敗しました");
    }
  }
}

// 初期化 / イベントバインド
window.onload = () => {
  const histField = document.getElementById('historyJsonInput');
  if(histField && histField.value){
    try {
      shufflyHistory = JSON.parse(histField.value);
      currentHistoryIndex = shufflyHistory.length - 1;
      if (currentHistoryIndex >= 0) {
        const val = shufflyHistory[currentHistoryIndex];
        setRawAndRefreshDisplay(val);
      }
    } catch(e) {
      shufflyHistory=[]; currentHistoryIndex=-1;
    }
  } else {
    // if no history stored, initialize display from membersRaw initial value
    updateDisplayFromRaw();
  }
  updateParticipantCount();
  if(shufflyHistory.length === 0) pushToHistory();
  switchResultTab('groups');
  switchSettingsTab('groups');

  // ensure stats collapsed state reflected on load
  const sc = document.getElementById('statsContainer');
  const btn = document.getElementById('btn-toggle-stats');
  if(sc && btn){
    if(statsCollapsed){
      sc.classList.add('hidden');
      btn.textContent = "統計情報を表示";
    } else {
      sc.classList.remove('hidden');
      btn.textContent = "統計情報を非表示";
    }
  }

  if(IS_SIGNED_IN){
    const pending = localStorage.getItem('pending_shuffly_event');
    if(pending){
      try {
        const p = JSON.parse(pending);
        if(p.members_json) document.getElementById('membersJsonInput').value = p.members_json;
        if(p.results_json) document.getElementById('resultsJsonInput').value = p.results_json;
        if(p.order_json) document.getElementById('orderJsonInput').value = p.order_json;
        if(p.settings_json) document.getElementById('settingsJsonInput').value = p.settings_json;
        if(p.history_json) document.getElementById('historyJsonInput').value = p.history_json;
        if(p.title && document.getElementById('hiddenEventTitle')) document.getElementById('hiddenEventTitle').value = p.title;
        const form = document.getElementById('saveForm');
        if(form){
          localStorage.removeItem('pending_shuffly_event');
          form.submit();
        }
      } catch(e){
        // ignore
      }
    }
  }
};

(function(){
  function bindIf(id, evt, handler){
    const el = document.getElementById(id);
    if(el) el.addEventListener(evt, handler);
  }

  // Visible membersInput: on user edit, parse back to raw and update hidden storage
  bindIf('membersInput', 'input', ()=>{
    if(suppressDisplayInput) return;
    const disp = getDisplayValue();
    const raw = parseDisplayToRaw(disp);
    setRawValue(raw);
    updateParticipantCount();
    pushToHistory();
  });

  bindIf('groupCount', 'input', ()=>{ updateParticipantCount(); /* do not auto-show groups/stats */ });
  bindIf('customGroupNames', 'input', ()=>{ /* no automatic group display */ });
  bindIf('rolesInput', 'input', ()=>{
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value=JSON.stringify({
      roles:document.getElementById('rolesInput').value,
      group_count: buildGroupIdsAndNames().groupCount
    });
  });

  // Import / paste (prevent default for link-style triggers)
  bindIf('btn-trigger-import', 'click', (e)=>{ e.preventDefault(); triggerImport(); });
  bindIf('importFile', 'change', handleImportFile);
  bindIf('btn-paste-clipboard', 'click', (e)=>{ e.preventDefault(); pasteFromClipboard(); });
  bindIf('btn-clear-history', 'click', (e)=>{ e.preventDefault(); clearMemberHistories(); });

  // Settings tabs
  bindIf('tab-settings-groups', 'click', ()=>switchSettingsTab('groups'));
  bindIf('tab-settings-order', 'click', ()=>switchSettingsTab('order'));
  bindIf('tab-settings-roles', 'click', ()=>switchSettingsTab('roles'));

  // Result tabs
  bindIf('tab-groups', 'click', ()=>switchResultTab('groups'));
  bindIf('tab-order', 'click', ()=>switchResultTab('order'));
  bindIf('tab-roles', 'click', ()=>switchResultTab('roles'));

  // Group view controls: SPAで即時反映
  bindIf('showGroupLabel', 'change', ()=>{ showGroups(); });
  bindIf('showGroupCount', 'change', ()=>{ showGroups(); });
  bindIf('breakMemberLine', 'change', ()=>{ showGroups(); });
  bindIf('separatorSelect', 'change', ()=>{ showGroups(); });
  bindIf('groupSeparatorSelect', 'change', ()=>{ showGroups(); });

  bindIf('btn-copy-groupoutput', 'click', (e)=>{ e.preventDefault(); copyGroupOutput(); });
  bindIf('btn-copy-orderoutput', 'click', (e)=>{ e.preventDefault(); copyOrderOutput(); });
  bindIf('btn-copy-rolesoutput', 'click', (e)=>{ e.preventDefault(); copyRolesOutput(); });

  // Toggle stats visibility (default collapsed)
  bindIf('btn-toggle-stats', 'click', (e)=>{
    if(e) e.preventDefault();
    const sc = document.getElementById('statsContainer');
    const btn = document.getElementById('btn-toggle-stats');
    if(!sc || !btn) return;
    sc.classList.toggle('hidden');
    statsCollapsed = sc.classList.contains('hidden');
    btn.textContent = statsCollapsed ? "統計情報を表示" : "統計情報を非表示";
    // update stats content whenever opened
    if(!statsCollapsed) showStats();
  });

  // Prev/Next links in results card (moved from settings area; same functionality, link style)
  bindIf('btn-prev-group', 'click', (e)=>{
    if(e) e.preventDefault();
    if(currentHistoryIndex <= 0){
      showToast("これ以上戻れません");
      return;
    }
    undoHistory();
  });
  bindIf('btn-next-group', 'click', (e)=>{
    if(e) e.preventDefault();
    if(currentHistoryIndex >= shufflyHistory.length-1){
      showToast("これ以上進めません");
      return;
    }
    redoHistory();
  });

  // Share controls
  bindIf('btn-toggle-presentation', 'click', (e)=>{ if(e) e.preventDefault(); togglePresentationMode(); });
  bindIf('btn-export-results', 'click', (e)=>{ if(e) e.preventDefault(); exportResults(); });
  bindIf('btn-save-results', 'click', (e)=>{ if(e) e.preventDefault(); saveResults(); });

  // Settings action buttons (find within containers and attach in order)
  const gAct = document.getElementById('settings-action-groups');
  if (gAct) {
    const btns = gAct.querySelectorAll('button, a[role="button"], a');
    if (btns[0]) btns[0].addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignGroups(); /* SPA: update panels without reload */ });
    // prev/next moved to results links
  }
  const oAct = document.getElementById('settings-action-order');
  if (oAct) {
    const b = oAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignOrder(); /* SPA: show order panel */ });
  }
  const rAct = document.getElementById('settings-action-roles');
  if (rAct) {
    const b = rAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignRoles(); /* SPA: show roles panel */ });
  }
})();
</script>