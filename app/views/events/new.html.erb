<div class="max-w-6xl mx-auto px-6 pt-2 pb-10">
  <h1 class="text-3xl font-bold mb-8"><%= @event.title.presence || "ğŸ“ ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ" %></h1>

  <div class="flex flex-col gap-6">

    <!-- â‘  ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¿½åŠ  -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">1</div>
        <h2 class="text-lg font-semibold">ãƒ¡ãƒ³ãƒãƒ¼ã‚’å…¥åŠ›</h2>
      </div>

      <label class="block text-sm font-medium mb-2">ãƒ¡ãƒ³ãƒãƒ¼åãƒªã‚¹ãƒˆï¼ˆæ”¹è¡Œã¾ãŸã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>

      <!-- hidden raw data textarea (æ©Ÿèƒ½ä¸Šã®ãƒ‡ãƒ¼ã‚¿ã¯ã“ã“ã«ä¿æŒ) -->
      <textarea id="membersRaw" rows="10" class="hidden" style="display:none;"><%= begin
        members = @event.members_json.present? ? JSON.parse(@event.members_json) : []
        members.map do |m|
          if m.is_a?(Hash)
            name = m["name"]
            hist = m["history"]&.join("") || ""
            "#{name}#{hist}"
          else
            m
          end
        end.join("\n")
      rescue JSON::ParserError
        ""
      end %></textarea>

      <!-- visible textarea for user (è¡¨ç¤ºã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ã¦è¦‹ã‚„ã™ãã™ã‚‹) -->
      <textarea id="membersInput" rows="10" class="w-full border rounded-md px-3 py-2" placeholder="ä¾‹ï¼šãƒ¡ãƒ³ãƒãƒ¼1, ãƒ¡ãƒ³ãƒãƒ¼2, ..."></textarea>
      <p class="text-xs text-gray-500 mt-0 mb-1">ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ¡ãƒ³ãƒãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</p>
      <div id="memberCountHint" class="text-xs text-gray-500 mt-1 mb-4 bg-gray-50 border rounded px-2 py-1">ï¼ˆãƒ¡ãƒ³ãƒãƒ¼æ•°ï¼šæœªå…¥åŠ›ï¼‰</div>

      <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
        <a href="#" id="btn-trigger-import" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">ãƒ†ã‚­ã‚¹ãƒˆ/CSVã‹ã‚‰å…¥åŠ›</a>
        <input id="importFile" type="file" accept=".txt,.csv" class="hidden">
        <a href="#" id="btn-paste-clipboard" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰å…¥åŠ›</a>
        <a href="#" id="btn-clear-history" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">å±¥æ­´ã‚’ã‚¯ãƒªã‚¢</a>
      </div>
    </div>

    <!-- â‘¡ è¨­å®šã‚’é¸æŠï¼ˆã‚¿ãƒ–åˆ‡æ›¿: ã‚°ãƒ«ãƒ¼ãƒ— / é †ç•ª / å½¹å‰²ï¼‰ -->
    <div class="bg-white rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">2</div>
        <h2 class="text-lg font-semibold">è¨­å®š / å®Ÿè¡Œ</h2>
      </div>

      <!-- ã‚¿ãƒ–ãƒœã‚¿ãƒ³ï¼ˆã‚«ãƒ¼ãƒ‰åã®ä¸‹ãƒ»ä¸­å¤®é…ç½®ãƒ»ä¸‹ç·šãƒãƒ¼é¢¨ï¼‰ -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-settings-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">ã‚°ãƒ«ãƒ¼ãƒ—è¨­å®š</button>
        <button id="tab-settings-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">é †ç•ªè¨­å®š</button>
        <button id="tab-settings-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">å½¹å‰²è¨­å®š</button>
      </div>

      <!-- ã‚°ãƒ«ãƒ¼ãƒ—ãƒ‘ãƒãƒ« -->
      <div id="panel-settings-groups" class="settings-panel">
        <div class="mb-4">
          <label class="block font-medium mb-1">ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã‚ªãƒ—ã‚·ãƒ§ãƒ³</label>
          <div class="flex flex-col gap-3 mb-2">
            <div>
              <label class="text-xs text-gray-600">ã‚°ãƒ«ãƒ¼ãƒ—æ•°</label>
              <input id="groupCount" type="number" min="1" max="26" value="<%= @event.group_count.presence || 3 %>" class="mt-1 w-full border rounded px-2 py-1 mb-1">
            </div>
            <div>
              <label class="text-xs text-gray-600">ã‚°ãƒ«ãƒ¼ãƒ—åï¼ˆä»»æ„ï¼šæ”¹è¡Œã¾ãŸã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>
              <textarea id="customGroupNames" rows="2" class="w-full border rounded px-2 py-1" placeholder="ä¾‹ï¼šã‚°ãƒ«ãƒ¼ãƒ—A, ã‚°ãƒ«ãƒ¼ãƒ—B, ..."></textarea>
              <p class="text-xs text-gray-500 mb-1">ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã™ã‚‹ã¨ã€ãã®æ•°ã«åˆã‚ã›ã¦ã‚°ãƒ«ãƒ¼ãƒ—æ•°ãŒè‡ªå‹•ã§è¨­å®šã•ã‚Œã¾ã™ã€‚</p>
            </div>
          </div>

          <div>
            <label class="text-xs text-gray-600">åˆ†æ•£å›ºå®šãƒ¡ãƒ³ãƒãƒ¼ï¼ˆä»»æ„ï¼šæ”¹è¡Œã¾ãŸã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>
            <textarea id="fixedMembersInput" rows="2" class="w-full border rounded px-2 py-1" placeholder="ä¾‹ï¼šãƒ¡ãƒ³ãƒãƒ¼3, ãƒ¡ãƒ³ãƒãƒ¼5, ..."></textarea>
            <p class="text-xs text-gray-500 mb-1">å…¥åŠ›ã•ã‚ŒãŸãƒ¡ãƒ³ãƒãƒ¼ã¯ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘å®Ÿè¡Œæ™‚ã«å¯èƒ½ãªé™ã‚Šåˆ†æ•£ã—ã€ã‚°ãƒ«ãƒ¼ãƒ—ã«å›ºå®šã—ã¾ã™ã€‚</p>
          </div>

          <div id="groupSizeHint" class="text-xs text-gray-500 mt-2 bg-gray-50 border rounded px-2 py-1">ï¼ˆ1ã‚°ãƒ«ãƒ¼ãƒ—ã‚ãŸã‚Šï¼šæœªè¨ˆç®—ï¼‰</div>
        </div>
      </div>

      <!-- é †ç•ªãƒ‘ãƒãƒ« -->
      <div id="panel-settings-order" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">é †ç•ªæ±ºã‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³</label>

          <div class="mb-2">
            <label class="text-xs text-gray-600">é †ç•ªå›ºå®šãƒ¡ãƒ³ãƒãƒ¼ï¼ˆä»»æ„ï¼šæ”¹è¡Œã¾ãŸã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>
            <textarea id="fixedOrderInput" rows="3" class="w-full border rounded px-2 py-1" placeholder="ä¾‹ï¼š1:ãƒ¡ãƒ³ãƒãƒ¼3, 5:ãƒ¡ãƒ³ãƒãƒ¼1, ..."></textarea>
            <p class="text-xs text-gray-500 mt-1">ã€Œå›ºå®šã™ã‚‹ç•ªå·:ãƒ¡ãƒ³ãƒãƒ¼åã€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚é †ç•ªæ±ºã‚å®Ÿè¡Œæ™‚ã«ãã®ç•ªå·ã«å¯¾å¿œã™ã‚‹ãƒ¡ãƒ³ãƒãƒ¼ãŒå›ºå®šã•ã‚Œã€æ®‹ã‚Šã®ãƒ¡ãƒ³ãƒãƒ¼ã¯ãƒ©ãƒ³ãƒ€ãƒ ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚</p>
          </div>

          <p class="text-xs text-gray-500 mt-2">å›ºå®šã‚’ä½¿ã‚ãªã„å ´åˆã¯ç©ºæ¬„ã®ã¾ã¾ã€Œé †ç•ªæ±ºã‚å®Ÿè¡Œã€ã‚’æŠ¼ã™ã¨å…¨å“¡ã®é †ç•ªãŒãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºã¾ã‚Šã¾ã™ã€‚</p>
        </div>
      </div>

      <!-- å½¹å‰²ãƒ‘ãƒãƒ«ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯é™¤å»ã€‚å½¹å‰²ã¯å¸¸ã«ãƒ©ãƒ³ãƒ€ãƒ ã‹ã¤ä¸€æ„ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ï¼‰ -->
      <div id="panel-settings-roles" class="settings-panel hidden">
        <div class="mb-4">
          <label class="block font-medium mb-1">å½¹å‰²æ±ºã‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³</label>
          <label class="text-xs text-gray-600">å½¹å‰²åï¼ˆæ”¹è¡Œã¾ãŸã¯ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>
          <textarea id="rolesInput" rows="3" class="w-full border rounded px-2 py-1" placeholder="ä¾‹ï¼šå¸ä¼š, æ›¸è¨˜, ..."><%= @event.setting_json["roles"] rescue "" %></textarea>

          <p class="text-xs text-gray-500 mt-2">è¤‡æ•°ã®å½¹å‰²ã‚’ã‚«ãƒ³ãƒã¾ãŸã¯æ”¹è¡Œã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚å½¹å‰²ã®å‰²ã‚Šå½“ã¦ã¯å¸¸ã«ãƒ©ãƒ³ãƒ€ãƒ ã«è¡Œã‚ã‚Œã€å„å½¹å‰²ã¯å¯èƒ½ãªé™ã‚Šç•°ãªã‚‹ãƒ¡ãƒ³ãƒãƒ¼ã«ä¸€æ„ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚</p>
        </div>
      </div>

      <!-- ãƒœã‚¿ãƒ³ç¾¤ï¼ˆãƒ‘ãƒãƒ«æ¯ã«è¡¨ç¤ºï¼‰ -->
      <!-- ã‚°ãƒ«ãƒ¼ãƒ—ç”¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
      <div id="settings-action-groups" class="mt-4">
        <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: 'ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘å®Ÿè¡Œ',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>

      <!-- é †ç•ªç”¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
      <div id="settings-action-order" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: 'é †ç•ªæ±ºã‚å®Ÿè¡Œ',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>

      <!-- å½¹å‰²ç”¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
      <div id="settings-action-roles" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <%= render 'shared/button',
                f: nil,
                button_text: 'å½¹å‰²æ±ºã‚å®Ÿè¡Œ',
                id: nil,
                path: '#',
                variant: 'primary',
                full_mobile: false,
                extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
        </div>
      </div>
    </div>

    <!-- â‘¢ çµæœ -->
    <div id="resultsCard" class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start justify-between mb-4">
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">3</div>
          <h2 class="text-lg font-semibold">çµæœã‚’è¡¨ç¤º</h2>
        </div>
      </div>

      <!-- ã‚¿ãƒ–ãƒœã‚¿ãƒ³ï¼ˆã‚«ãƒ¼ãƒ‰åã®ä¸‹ãƒ»ä¸­å¤®é…ç½®ãƒ»ä¸‹ç·šãƒãƒ¼é¢¨ï¼‰ -->
      <div class="flex justify-center gap-4 mb-4 border-b border-gray-200">
        <button id="tab-groups" class="px-3 py-2 -mb-px border-b-2 border-blue-500 text-sm font-medium">ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤º</button>
        <button id="tab-order"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">é †ç•ªè¡¨ç¤º</button>
        <button id="tab-roles"  class="px-3 py-2 -mb-px border-b-2 border-transparent text-sm">å½¹å‰²è¡¨ç¤º</button>
      </div>

      <!-- ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºï¼‹çµ±è¨ˆï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºï¼‰ -->
      <div id="panel-groups" class="result-panel">
        <h3 class="font-medium mb-2">ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤º</h3>

        <div class="mb-2">
          <div class="flex flex-col sm:flex-row sm:items-center gap-2">
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="showGroupLabel" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">ã‚°ãƒ«ãƒ¼ãƒ—åè¡¨ç¤º</span>
            </label>
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="showGroupCount" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">ã‚°ãƒ«ãƒ¼ãƒ—äººæ•°è¡¨ç¤º</span>
            </label>
            <label class="inline-flex items-center gap-1 mt-2">
              <input type="checkbox" id="breakMemberLine" checked class="rounded border-gray-300">
              <span class="text-sm ml-2">ãƒ¡ãƒ³ãƒãƒ¼ã‚’æ”¹è¡Œè¡¨ç¤º</span>
            </label>
          </div>

          <div class="mt-2 flex flex-col sm:flex-row sm:items-start gap-3">
            <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
              <label class="text-sm mr-0 sm:mr-2 mb-1 sm:mb-0">ãƒ¡ãƒ³ãƒãƒ¼ã®åŒºåˆ‡ã‚Šæ–¹ :</label>
              <select id="separatorSelect" class="border rounded-md px-2 py-1 mt-0 sm:mt-1 w-full sm:w-auto">
                <option value=" " >ã‚¹ãƒšãƒ¼ã‚¹</option>
                <option value="," selected>ã‚«ãƒ³ãƒ</option>
                <option value="\\n">æ”¹è¡Œ</option>
                <option value="  ">ãƒ€ãƒ–ãƒ«ã‚¹ãƒšãƒ¼ã‚¹</option>
                <option value="\\t">ã‚¿ãƒ–</option>
              </select>
            </div>

            <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
              <label class="text-sm mr-0 sm:mr-2 mb-1 sm:mb-0">ã‚°ãƒ«ãƒ¼ãƒ—ã®åŒºåˆ‡ã‚Šæ–¹ :</label>
              <select id="groupSeparatorSelect" class="border rounded-md px-2 py-1 mt-0 sm:mt-1 w-full sm:w-auto">
                <option value="space">ã‚¹ãƒšãƒ¼ã‚¹</option>
                <option value="none" selected>ãªã—</option>
                <option value="line">ç·š</option>
                <option value="wave">æ³¢ç·š</option>
              </select>
            </div>
          </div>
        </div>

        <!-- çµæœè¡¨ç¤ºãƒ•ã‚©ãƒ¼ãƒ è‰²ã‚’è–„ã„ã‚°ãƒ¬ãƒ¼ç³»ã«å¤‰æ›´ -->
        <!-- åˆæœŸã¯ç©ºã€‚ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘å®Ÿè¡Œãƒœã‚¿ãƒ³æŠ¼ä¸‹å¾Œã«åˆå›è¡¨ç¤ºã•ã‚Œã‚‹ -->
        <textarea id="groupOutput" rows="10" readonly class="bg-gray-50 text-gray-500 border rounded-md px-3 py-2 w-full mb-4 text-lg"></textarea>

        <!-- çµ±è¨ˆæƒ…å ±ï¼ˆæŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ãƒ»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æŠ˜ã‚ŠãŸãŸã¿ï¼‰ -->
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-medium"><a href="#" id="btn-toggle-stats" class="hover:underline">çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º</a></h3>
        </div>
        <div id="statsContainer" class="hidden">
          <textarea id="statsOutput" rows="10" readonly class="bg-gray-50 text-gray-500 border rounded-md px-3 py-2 w-full text-sm mb-3"></textarea>
        </div>

        <!-- ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼ / å±¥æ­´ç§»å‹•ï¼ˆãƒªãƒ³ã‚¯ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰ -->
        <div class="flex flex-col md:flex-row gap-2 items-center justify-center w-full">
          <a href="#" id="btn-prev-group" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">å‰å›ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã¸</a>
          <a href="#" id="btn-next-group" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">æ¬¡å›ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã¸</a>
          <a href="#" id="btn-copy-groupoutput" class="w-full sm:flex-1 text-center text-sm text-blue-600 hover:underline">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</a>
        </div>

      </div>

      <!-- é †ç•ªè¡¨ç¤ºãƒ‘ãƒãƒ« -->
      <div id="panel-order" class="result-panel hidden">
        <h3 class="font-medium mb-2">é †ç•ªè¡¨ç¤º</h3>
        <textarea id="orderOutput" rows="10" readonly class="bg-gray-50 text-gray-500 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-orderoutput" class="text-sm text-blue-600 hover:underline">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</a>
        </div>
      </div>

      <!-- å½¹å‰²è¡¨ç¤ºãƒ‘ãƒãƒ« -->
      <div id="panel-roles" class="result-panel hidden">
        <h3 class="font-medium mb-2">å½¹å‰²è¡¨ç¤º</h3>
        <textarea id="rolesOutput" rows="10" readonly class="bg-gray-50 text-gray-500 border rounded-md px-3 py-2 w-full text-lg"></textarea>

        <div class="flex justify-center mt-2 w-full">
          <a href="#" id="btn-copy-rolesoutput" class="text-sm text-blue-600 hover:underline">ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</a>
        </div>
      </div>
    </div>

    <!-- â‘£ å‡ºåŠ› -->
    <div class="bg-blue-50 rounded-lg shadow-sm p-6">
      <div class="flex items-start gap-3 mb-4">
        <div class="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center font-bold">4</div>
        <h2 class="text-lg font-semibold">å…±æœ‰ / å‡ºåŠ› / ä¿å­˜</h2>
      </div>

      <label class="block text-sm font-medium mb-2">ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒˆãƒ«ï¼ˆä»»æ„ï¼‰</label>
      <!-- ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒˆãƒ«ãƒ•ã‚©ãƒ¼ãƒ ã®è‰²ã‚’ç™½ç³»ã«æˆ»ã™ -->
      <input id="shareEventTitle" type="text" value="<%= @event.title %>" class="w-full border rounded px-3 py-2 mb-3 bg-white" placeholder="ä¾‹ï¼šã€‡ã€‡ã‚¤ãƒ™ãƒ³ãƒˆ">

      <div class="flex flex-col md:flex-row gap-2 mb-3 items-center justify-center w-full">
        <%= render 'shared/button',
              f: nil,
              button_text: 'ç”»é¢å…±æœ‰è¡¨ç¤º',
              id: 'btn-toggle-presentation',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›',
              id: 'btn-export-results',
              path: '#',
              variant: 'secondary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-white border rounded-lg text-blue-600 hover:bg-gray-50' %>
        <%= render 'shared/button',
              f: nil,
              button_text: 'ã‚¤ãƒ™ãƒ³ãƒˆä¿å­˜',
              id: 'btn-save-results',
              path: '#',
              variant: 'primary',
              full_mobile: false,
              extra_class: 'w-full sm:flex-1 text-center px-6 py-3 bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600' %>
      </div>

      <p class="text-xs text-gray-500">ã‚¤ãƒ™ãƒ³ãƒˆä¿å­˜ã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ã€‚</p>

      <!-- hidden ä¿å­˜ãƒ•ã‚©ãƒ¼ãƒ ï¼ˆsubmit ã¯ saveResults() ãŒåˆ¶å¾¡ï¼‰ -->
      <%= form_with(model: @event, local: true, html: { id: 'saveForm', style: 'display:none' }) do |f| %>
        <%= f.hidden_field :members_json, id: 'membersJsonInput' %>
        <%= f.hidden_field :member_results_json, id: 'resultsJsonInput' %>
        <%= f.hidden_field :member_order_json, id: 'orderJsonInput' %>
        <%= f.hidden_field :setting_json, id: 'settingsJsonInput' %>
        <%= f.hidden_field :history_json, id: 'historyJsonInput' %>
        <%= f.hidden_field :title, value: @event.title, name: 'event[title]', id: 'hiddenEventTitle' %>
      <% end %>
    </div>

  </div>

  <div id="toast" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-black text-white px-4 py-2 rounded opacity-0 transition-opacity"></div>
</div>

<script>
let shufflyHistory = [], currentHistoryIndex = -1;
const IS_SIGNED_IN = <%= user_signed_in? ? 'true' : 'false' %>;
let statsCollapsed = true; // çµ±è¨ˆæƒ…å ±ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æŠ˜ã‚ŠãŸãŸã¿

// --- helper functions (existing) ---
function clampGroupCount(v){
  return Math.min(Math.max(parseInt(v) || 1, 1), 26);
}
function parseEntry(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  return {name, history: hist};
}
function getCurrentRound(entries){
  let max=0;
  for(const e of entries) for(const h of e.history) {
    const m = h.match(/^#(\d+)/);
    if(m) max=Math.max(max, parseInt(m[1]));
  }
  return max+1;
}
function getCoOccurrenceMap(entries, ignoreLast=true){
  const map={}, histories={};
  for(const e of entries) histories[e.name]=ignoreLast?e.history.slice(0,-1):e.history;
  for(const e of entries) map[e.name]={};
  for(const a of entries){
    for(const b of entries){
      if(a.name===b.name) continue;
      const overlap=histories[a.name].filter(h=>histories[b.name].includes(h));
      map[a.name][b.name]=overlap.length;
    }
  }
  return map;
}

// å…±é€š: ã‚°ãƒ«ãƒ¼ãƒ—ID(A,B,...)ã¨è¡¨ç¤ºåã®æ±ºå®š
function buildGroupIdsAndNames(){
  const groupCountInputEl = document.getElementById('groupCount');
  const inputGroupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  const customNamesEl = document.getElementById('customGroupNames');
  const customNames = (customNamesEl ? customNamesEl.value : "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);

  let groupCount;
  let ids = [];
  let displayNames = [];

  if(customNames.length > 0){
    groupCount = Math.min(customNames.length, 26);
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = customNames.slice(0, groupCount);
  } else {
    groupCount = inputGroupCount;
    ids = Array.from({length: groupCount}, (_,i)=>String.fromCharCode(65+i));
    displayNames = ids.slice();
  }

  const idToName = {};
  ids.forEach((id, idx) => idToName[id] = displayNames[idx] || id);
  return { ids, displayNames, idToName, groupCount };
}

// --- New helpers for display-only formatted history ---
let suppressDisplayInput = false;

function getRawValue(){ return (document.getElementById('membersRaw') || {value:''}).value || ""; }
function setRawValue(v){ const el = document.getElementById('membersRaw'); if(el) el.value = v; }

function getDisplayValue(){ return (document.getElementById('membersInput') || {value:''}).value || ""; }
function setDisplayValue(v){ const el = document.getElementById('membersInput'); if(el) el.value = v; }

function formatEntryForDisplay(entry){
  const name = entry.split('#')[0].trim();
  const hist = entry.match(/#\d+[A-Z]/g) || [];
  const { idToName } = buildGroupIdsAndNames();
  const formattedHist = hist.map(h=>{
    const m=h.match(/^#(\d+)([A-Z])$/);
    if(m){
      const num=m[1], id=m[2];
      const gname = idToName[id] || id;
      return ` [ ${num}å›ç›®ï¼š${gname} ]`;
    }
    return h;
  }).join('');
  return `${name}${formattedHist}`;
}

function updateDisplayFromRaw(){
  const raw = getRawValue();
  const lines = raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const formatted = lines.map(formatEntryForDisplay).join("\n");
  suppressDisplayInput = true;
  setDisplayValue(formatted);
  setTimeout(()=>{ suppressDisplayInput = false; }, 0);
}

function parseDisplayToRaw(displayText){
  const { idToName } = buildGroupIdsAndNames();
  const nameToId = {};
  for(const k in idToName) nameToId[idToName[k]] = k;

  const lines = displayText.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const rawLines = lines.map(line=>{
    const parts = line.split('#').filter(Boolean);
    if(parts.length === 0) return "";
    const base = parts[0].trim();
    const tokens = parts.slice(1);
    const rawTokens = tokens.map(tok=>{
      const mRaw = tok.match(/^(\d+)([A-Z])$/);
      if(mRaw) return `#${mRaw[1]}${mRaw[2]}`;
      const m = tok.match(/^(\d+)\s*å·¡ç›®\s*[:ï¼š]\s*(.+)$/);
      if(m){
        const num = m[1];
        const gname = m[2].trim();
        let id = nameToId[gname];
        if(!id){
          const stripped = gname.replace(/^ã‚°ãƒ«ãƒ¼ãƒ—\s*/i,'').trim();
          id = nameToId[stripped];
        }
        if(id) return `#${num}${id}`;
        return `#${num}`;
      }
      return `#${tok.replace(/^#?/,'')}`;
    }).filter(Boolean);
    return base + rawTokens.join('');
  }).filter(Boolean);
  return rawLines.join("\n");
}

function setRawAndRefreshDisplay(rawText){
  setRawValue(rawText);
  updateDisplayFromRaw();
}

// --- Adjusted core functions to use raw storage (membersRaw) for processing ---
function assignGroups(){
  let raw = getRawValue().trim();
  let rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let entries = rawList.map(parseEntry);
  const round=getCurrentRound(entries);

  const { ids: groupIds, idToName, groupCount } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  const coMap=getCoOccurrenceMap(entries);

  const fixedRaw = (document.getElementById('fixedMembersInput').value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedSet = new Set(fixedRaw);
  const fixedEntries = entries.filter(e=>fixedSet.has(e.name));
  const otherEntries = entries.filter(e=>!fixedSet.has(e.name));

  // helper: pick random element from array
  function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // assign fixed entries but randomize among empty/min candidates to avoid left-bias
  for(const p of fixedEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    let chosen;
    if(emptyGroups.length>0){
      chosen = pickRandom(emptyGroups);
    } else {
      const minSize = Math.min(...groupIds.map(g=>groups[g].length));
      const candidates = groupIds.filter(g=>groups[g].length===minSize);
      chosen = pickRandom(candidates);
    }
    groups[chosen].push(p);
    p.assignedGroup = chosen; // preserve assignment on the original entry object
  }

  for(const p of otherEntries){
    const emptyGroups = groupIds.filter(g=>groups[g].length===0);
    if(emptyGroups.length>0){
      const chosen = pickRandom(emptyGroups);
      groups[chosen].push(p);
      p.assignedGroup = chosen;
      continue;
    }

    const minSize=Math.min(...groupIds.map(g=>groups[g].length));
    const candidates=groupIds.filter(g=>groups[g].length===minSize);

    // compute co-occurrence score (mk) for each candidate and choose among ties randomly
    let minMK=Infinity;
    const scores=[];
    for(const g of candidates){
      const mk=groups[g].reduce((acc,q)=>acc+(coMap[p.name][q.name]||0),0);
      scores.push({g, mk});
      if(mk<minMK) minMK=mk;
    }
    const tied = scores.filter(s=>s.mk===minMK).map(s=>s.g);
    const selected = pickRandom(tied);
    groups[selected].push(p);
    p.assignedGroup = selected;
  }

  // Accept roles input separated by comma or newline
  const rolesForGroups = document.getElementById('rolesInput').value.split(/[\r\n,]+/).map(r=>r.trim()).filter(Boolean);
  if(rolesForGroups.length>0){
    for(const g of groupIds){
      const members=groups[g];
      members.forEach((m,i)=>m.role=rolesForGroups[i%rolesForGroups.length]);
    }
  }

  // Preserve original input order when appending history: build updated lines from entries array order
  const updated = entries.map(e => {
    const assigned = e.assignedGroup || (()=>{
      // fallback: find in groups if assignment missing
      for(const g of groupIds) if(groups[g].some(x=>x.name===e.name)) return g;
      return groupIds[0];
    })();
    return `${e.name}${e.history.join('')}#${round}${assigned}`;
  });

  setRawAndRefreshDisplay(updated.join("\n"));

  try{
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: groups, group_names: buildGroupIdsAndNames().idToName });
    document.getElementById('settingsJsonInput').value = JSON.stringify({
      roles: document.getElementById('rolesInput').value,
      group_count: groupCount,
      custom_group_names: (document.getElementById('customGroupNames').value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean)
    });
  }catch(e){
    console.warn("JSON ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¤±æ•—:", e);
  }

  updateParticipantCount(); showGroups(); showStats(); pushToHistory();
  switchResultTab('groups');
}

function assignOrder(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length === 0){
    document.getElementById('orderOutput').value = "";
    if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = "[]";
    showToast("å‚åŠ è€…ãŒã„ã¾ã›ã‚“");
    return;
  }

  const fixedRaw = (document.getElementById('fixedOrderInput')?.value || "").split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
  const fixedMap = {};
  const invalids = [];
  for(const line of fixedRaw){
    if(!line) continue;
    const m = line.match(/^(\d+)\s*[:=]\s*(.+)$/) || line.match(/^(\d+)\s+(.+)$/);
    if(m){
      const pos = parseInt(m[1],10);
      const name = m[2].trim();
      if(pos >= 1 && pos <= members.length){
        fixedMap[pos] = name;
      } else {
        invalids.push(line);
      }
    } else {
      invalids.push(line);
    }
  }

  const namesSet = new Set(members);
  const assignedFixedNames = new Set();
  const invalidNameEntries = [];
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    const name = fixedMap[pos];
    if(!namesSet.has(name)){
      invalidNameEntries.push(`${pos}: ${name}`);
      delete fixedMap[pos];
    } else {
      assignedFixedNames.add(name);
    }
  }

  if(invalids.length>0 || invalidNameEntries.length>0){
    const msgs = [];
    if(invalids.length>0) msgs.push("å›ºå®šæŒ‡å®šã®æ›¸å¼ãŒä¸æ­£ãªè¡ŒãŒã‚ã‚Šã¾ã™");
    if(invalidNameEntries.length>0) msgs.push("ãƒ¡ãƒ³ãƒãƒ¼ã«å­˜åœ¨ã—ãªã„åå‰ã®å›ºå®šæŒ‡å®šãŒã‚ã‚Šã¾ã™");
    showToast(msgs.join('ã€') + "ï¼ˆç„¡è¦–ã•ã‚Œã¾ã™ï¼‰");
  }

  const pool = members.filter(m=>!assignedFixedNames.has(m));
  for(let i=pool.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [pool[i], pool[j]]=[pool[j], pool[i]];
  }

  const result = Array(members.length).fill(null);
  for(const posStr in fixedMap){
    const pos = parseInt(posStr,10);
    result[pos-1] = fixedMap[pos];
  }

  let poolIdx = 0;
  for(let i=0;i<result.length;i++){
    if(result[i] === null){
      result[i] = pool[poolIdx++] || "";
    }
  }

  const lines = result.map((name, idx) => `${idx+1}. ${name}`);
  document.getElementById('orderOutput').value = lines.join("\n");

  const orderJson = result.map((name, idx) => ({ name, order: idx+1 }));
  if(document.getElementById('orderJsonInput')) document.getElementById('orderJsonInput').value = JSON.stringify(orderJson);

  showToast("é †ç•ªã‚’å‰²ã‚Šå½“ã¦ã¾ã—ãŸ");
  switchResultTab('order');
}

function assignRoles(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  let members = rawList.map(s=>s.split('#')[0].trim());
  if(members.length===0){ showToast("ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ã¾ã›ã‚“"); return; }

  // Accept roles separated by comma or newline
  const roles = document.getElementById('rolesInput').value.split(/[\r\n,]+/).map(r=>r.trim()).filter(Boolean);
  if(roles.length===0){ showToast("å½¹å‰²ãŒæœªå…¥åŠ›ã§ã™"); return; }

  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]]=[arr[j], arr[i]];
    }
  }

  const pool = members.slice();
  shuffleArray(pool);

  const assignments = [];
  for(let i=0;i<roles.length && i<pool.length;i++){
    assignments.push({ name: pool[i], role: roles[i] });
  }
  const assignedNames = new Set(assignments.map(a=>a.name));
  for(const m of members){
    if(!assignedNames.has(m)) assignments.push({ name: m, role: null });
  }

  const displayLines = assignments.map(a => a.role ? `${a.name}: ${a.role}` : `${a.name}: `);
  document.getElementById('rolesOutput').value = displayLines.join("\n");

  try {
    const settingsField = document.getElementById('settingsJsonInput');
    let settings = {};
    if(settingsField && settingsField.value) {
      try { settings = JSON.parse(settingsField.value); } catch(e){ settings = {}; }
    }
    settings.role_assignments = assignments.map(a => ({ name: a.name, role: a.role }));
    if(settingsField) settingsField.value = JSON.stringify(settings);
  } catch(e){
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value = JSON.stringify({ role_assignments: assignments.map(a=>({ name:a.name, role: a.role })) });
  }

  showToast("å½¹å‰²ã‚’å‰²ã‚Šå½“ã¦ã¾ã—ãŸ");
  switchResultTab('roles');
}

function showGroups(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries = rawList.map(parseEntry);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groups=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)) {
      let empty = groupIds.find(g=>groups[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groups[g].length));
        id = groupIds.find(g=>groups[g].length===minSize);
      }
    }
    groups[id].push(e.name);
  }

  // separator support: space, comma (default), double-space, tab, newline
  const sepVal = document.getElementById('separatorSelect').value;
  const memberSep = sepVal==='\\t' ? '\t' : (sepVal==='\\n' ? '\n' : sepVal);
  const showLabel=document.getElementById('showGroupLabel').checked;
  const showCount=document.getElementById('showGroupCount') ? document.getElementById('showGroupCount').checked : true;
  const breakMemberLine = document.getElementById('breakMemberLine') ? document.getElementById('breakMemberLine').checked : true;
  const groupSepVal = document.getElementById('groupSeparatorSelect') ? document.getElementById('groupSeparatorSelect').value : 'space';

  let groupSep = '\n\n'; // default to previous behaviour
  if(groupSepVal === 'none') groupSep = '\n'; // minimal: single newline
  else if(groupSepVal === 'space') groupSep = '\n\n';
  else if(groupSepVal === 'line') groupSep = '\nâ”€â”€â”€â”€â”€â”€â”€â”€\n';
  else if(groupSepVal === 'wave') groupSep = '\nã€œã€œã€œã€œã€œã€œã€œ\n';

  const parts = [];
  for(const id of groupIds){
    const members=groups[id];
    const label = idToName[id] || id;
    let block = '';
    if(showLabel){
      const countText = showCount ? `ï¼ˆ${members.length}äººï¼‰` : '';
      // When breakMemberLine is true, keep newline after label; otherwise keep header and members inline
      block += breakMemberLine ? `${label}${countText}ï¼š\n` : `${label}${countText}ï¼š `;
    }
    block += members.join(memberSep);
    parts.push(block);
  }

  const display = parts.join(groupSep);
  document.getElementById('groupOutput').value=display.trim();
}

function showStats(){
  const raw = getRawValue().trim();
  const rawList = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean) : [];
  const entries=rawList.map(parseEntry);
  const coMap=getCoOccurrenceMap(entries,true);

  const { ids: groupIds, idToName } = buildGroupIdsAndNames();
  const groupMap=Object.fromEntries(groupIds.map(g=>[g,[]]));
  for(const e of entries){
    const last=e.history.at(-1);
    const m = last ? last.match(/#\d+([A-Z])$/) : null;
    let id = m ? m[1] : null;
    if(!id || !groupIds.includes(id)){
      let empty = groupIds.find(g=>groupMap[g].length===0);
      if(empty) id = empty;
      else {
        const minSize = Math.min(...groupIds.map(g=>groupMap[g].length));
        id = groupIds.find(g=>groupMap[g].length===minSize);
      }
    }
    groupMap[id].push(e.name);
  }

  // group separator should reflect the UI option (same mapping as showGroups)
  const groupSepVal = document.getElementById('groupSeparatorSelect') ? document.getElementById('groupSeparatorSelect').value : 'space';
  let groupSep = '\n\n';
  if(groupSepVal === 'none') groupSep = '\n';
  else if(groupSepVal === 'space') groupSep = '\n\n';
  else if(groupSepVal === 'line') groupSep = '\nâ”€â”€â”€â”€â”€â”€â”€â”€\n';
  else if(groupSepVal === 'wave') groupSep = '\nã€œã€œã€œã€œã€œã€œã€œ\n';

  const parts = [];
  for(const id of groupIds){
    const members=groupMap[id];
    let total=0;
    const memberLines = [];
    for(const m of members){
      const mk=members.reduce((sum,other)=>sum+(m!==other?(coMap[m][other]||0):0),0);
      memberLines.push(`${m}ï¼šåŒã‚°ãƒ«ãƒ¼ãƒ—å›æ•°ï¼${mk}`);
      total+=mk;
    }
    const header = `${idToName[id] ? `ã‚°ãƒ«ãƒ¼ãƒ— ${idToName[id]}` : `ã‚°ãƒ«ãƒ¼ãƒ— ${id}`}ï¼ˆåŒã‚°ãƒ«ãƒ¼ãƒ—å›æ•°å¹³å‡ï¼${members.length? (total/members.length).toFixed(2):0}ï¼‰ï¼š`;
    const block = [header].concat(memberLines).join("\n");
    parts.push(block);
  }

  document.getElementById('statsOutput').value = parts.join(groupSep).trim();
}

function updateParticipantCount(){
  const raw = getRawValue().trim();
  const count = raw ? raw.split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean).length : 0;
  const span=document.getElementById('groupSizeHint');
  const memberSpan=document.getElementById('memberCountHint');

  // Use number of custom group names if provided; otherwise fall back to groupCount input
  const customNamesEl = document.getElementById('customGroupNames');
  let groupCount;
  if(customNamesEl){
    const customNames = (customNamesEl.value || "").split(/[\r\n,]+/).map(n=>n.trim()).filter(Boolean);
    if(customNames.length > 0) groupCount = Math.min(customNames.length, 26);
  }
  if(!groupCount){
    const groupCountInputEl = document.getElementById('groupCount');
    groupCount = clampGroupCount(groupCountInputEl ? groupCountInputEl.value : 3);
  }

  // update member count hint (å¸¸æ™‚è¡¨ç¤º)
  if(memberSpan){
    memberSpan.textContent = count ? `ãƒ¡ãƒ³ãƒãƒ¼æ•°ï¼š${count}äºº` : 'ãƒ¡ãƒ³ãƒãƒ¼æ•°ï¼šæœªå…¥åŠ›';
  }

  // update group size hint (å¸¸æ™‚è¡¨ç¤º)
  if(span){
    if(count === 0){
      span.textContent = '1ã‚°ãƒ«ãƒ¼ãƒ—ã‚ãŸã‚Šï¼šæœªè¨ˆç®—';
    } else {
      const min=Math.floor(count/groupCount), max=Math.ceil(count/groupCount);
      span.textContent = min===max?`1ã‚°ãƒ«ãƒ¼ãƒ—ã‚ãŸã‚Šï¼š${min}äºº`:`1ã‚°ãƒ«ãƒ¼ãƒ—ã‚ãŸã‚Šï¼š${min}ã€œ${max}äºº`;
    }
  }
}

function copyGroupOutput(){ navigator.clipboard.writeText(document.getElementById('groupOutput').value).then(()=>showToast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼")).catch(()=>showToast("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ")); }
function copyOrderOutput(){ navigator.clipboard.writeText(document.getElementById('orderOutput').value).then(()=>showToast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼")).catch(()=>showToast("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ")); }
function copyRolesOutput(){ navigator.clipboard.writeText(document.getElementById('rolesOutput').value).then(()=>showToast("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼")).catch(()=>showToast("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ")); }

function showToast(msg){
  const toast=document.getElementById('toast');
  toast.textContent=msg;
  toast.classList.remove("opacity-0");
  setTimeout(()=>toast.classList.add("opacity-0"),1200);
}

function pushToHistory(){
  const text = getRawValue();
  if(currentHistoryIndex>=0 && shufflyHistory[currentHistoryIndex]===text) return;
  shufflyHistory = shufflyHistory.slice(0,currentHistoryIndex+1);
  shufflyHistory.push(text);
  currentHistoryIndex++;
  const histField = document.getElementById('historyJsonInput');
  if(histField) histField.value=JSON.stringify(shufflyHistory);
}

function undoHistory(){
  if(currentHistoryIndex>0){
    currentHistoryIndex--;
    const val = shufflyHistory[currentHistoryIndex];
    setRawAndRefreshDisplay(val);
    updateParticipantCount();
    showGroups();
    showStats();
    try{
      const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
      if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    }catch(e){}
    showToast("1ã‚¹ãƒ†ãƒƒãƒ—æˆ»ã—ã¾ã—ãŸ");
    switchResultTab('groups');
  } else showToast("ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“");
}

function redoHistory(){
  if(currentHistoryIndex<shufflyHistory.length-1){
    currentHistoryIndex++;
    const val = shufflyHistory[currentHistoryIndex];
    setRawAndRefreshDisplay(val);
    updateParticipantCount();
    showGroups();
    showStats();
    try{
      const entries = val ? val.split(/[\r\n,]+/).map(s=>parseEntry(s.trim())) : [];
      if(document.getElementById('membersJsonInput')) document.getElementById('membersJsonInput').value = JSON.stringify(entries);
    }catch(e){}
    showToast("1ã‚¹ãƒ†ãƒƒãƒ—é€²ã‚ã¾ã—ãŸ");
    switchResultTab('groups');
  } else showToast("ã“ã‚Œä»¥ä¸Šé€²ã‚ã¾ã›ã‚“");
}

// çµæœã‚¿ãƒ–åˆ‡æ›¿
function switchResultTab(name){
  document.querySelectorAll('.result-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-groups, #tab-order, #tab-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-groups').classList.remove('hidden'); const el=document.getElementById('tab-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-order').classList.remove('hidden'); const el=document.getElementById('tab-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-roles').classList.remove('hidden'); const el=document.getElementById('tab-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
}

// è¨­å®šã‚¿ãƒ–åˆ‡æ›¿ï¼ˆæ–°è¦ï¼‰
function switchSettingsTab(name){
  document.querySelectorAll('.settings-panel').forEach(el=>el.classList.add('hidden'));

  document.querySelectorAll('#tab-settings-groups, #tab-settings-order, #tab-settings-roles').forEach(b=>{
    b.classList.remove('border-blue-500','text-blue-600','font-medium');
    b.classList.add('border-transparent','text-gray-600');
  });

  if(name==='groups'){ document.getElementById('panel-settings-groups').classList.remove('hidden'); const el=document.getElementById('tab-settings-groups'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='order'){ document.getElementById('panel-settings-order').classList.remove('hidden'); const el=document.getElementById('tab-settings-order'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }
  if(name==='roles'){ document.getElementById('panel-settings-roles').classList.remove('hidden'); const el=document.getElementById('tab-settings-roles'); el.classList.remove('border-transparent'); el.classList.add('border-blue-500','text-blue-600','font-medium'); }

  const gAct = document.getElementById('settings-action-groups');
  const oAct = document.getElementById('settings-action-order');
  const rAct = document.getElementById('settings-action-roles');
  if(gAct) gAct.classList.add('hidden');
  if(oAct) oAct.classList.add('hidden');
  if(rAct) rAct.classList.add('hidden');
  if(name==='groups' && gAct) gAct.classList.remove('hidden');
  if(name==='order' && oAct) oAct.classList.remove('hidden');
  if(name==='roles' && rAct) rAct.classList.remove('hidden');
}

// ã‚¤ãƒ³ãƒãƒ¼ãƒˆè£œåŠ©
function triggerImport(){ const f = document.getElementById('importFile'); if(f) f.click(); }
function handleImportFile(e){
  const file = e.target.files ? e.target.files[0] : null;
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const text = ev.target.result;
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + text.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ");
  };
  reader.readAsText(file, 'utf-8');
}
function pasteFromClipboard(){
  navigator.clipboard.readText().then(txt=>{
    const cur = getRawValue().trim();
    const merged = (cur?cur + "\n":"") + txt.replace(/\r/g,'').trim();
    setRawAndRefreshDisplay(merged);
    updateParticipantCount(); pushToHistory();
    showToast("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰è²¼ã‚Šä»˜ã‘ã¾ã—ãŸ");
  }).catch(()=>showToast("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“"));
}

// å±¥æ­´ã‚¯ãƒªã‚¢ï¼ˆãƒ¡ãƒ³ãƒãƒ¼åä»¥é™ã‚’ä¸€æ‹¬å‰Šé™¤ï¼‰
function clearMemberHistories(){
  const confirmed = window.confirm("ãƒ¡ãƒ³ãƒãƒ¼åãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹å…¨ãƒ¡ãƒ³ãƒãƒ¼ã®å±¥æ­´ã‚’ä¸€æ‹¬ã§å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ");
  if(!confirmed) return;

  const cur = getRawValue() || "";
  const cleaned = cur.split(/[\r\n,]+/).map(s=>s.split('#')[0].trim()).filter(Boolean);
  setRawAndRefreshDisplay(cleaned.join("\n"));

  // update hidden members json field as well
  try{
    const entries = cleaned.map(s=>parseEntry(s));
    const mj = document.getElementById('membersJsonInput');
    if(mj) mj.value = JSON.stringify(entries);
  }catch(e){}

  updateParticipantCount();
  pushToHistory();
  showToast("å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
}

function togglePresentationMode(){
  try{
    const payload = {
      members_json: (()=>{ try { return JSON.parse(document.getElementById('membersJsonInput')?.value || '[]'); } catch(e){ return getRawValue() || ""; } })(),
      results_json: (()=>{ try { return JSON.parse(document.getElementById('resultsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('resultsJsonInput')?.value || ""; } })(),
      order_json: (()=>{ try { return JSON.parse(document.getElementById('orderJsonInput')?.value || '[]'); } catch(e){ return document.getElementById('orderOutput')?.value || ""; } })(),
      settings_json: (()=>{ try { return JSON.parse(document.getElementById('settingsJsonInput')?.value || '{}'); } catch(e){ return document.getElementById('settingsJsonInput')?.value || ""; } })(),
      history_json: document.getElementById('historyJsonInput')?.value || "",
      title: document.getElementById('shareEventTitle')?.value || document.title || ''
    };
    localStorage.setItem('presentation_shuffly_event', JSON.stringify(payload));
  }catch(e){
    console.warn('presentation payload store failed', e);
  }

  const presentationPath = '/events/show';
  const w = window.open(presentationPath, '_blank', 'noopener');
  if(!w) showToast("ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¨±å¯ã—ã¦ãã ã•ã„");

  // --- é€ä¿¡éƒ¨: BroadcastChannel ãŒã‚ã‚Œã°åˆæœŸãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’é€ã‚‹ï¼ˆæ—¢å­˜ã®æ©Ÿèƒ½ã«ã¯å½±éŸ¿ã—ãªã„ï¼‰
  try {
    if (typeof BroadcastChannel !== 'undefined') {
      const bc = new BroadcastChannel('shuffly_channel');
      // defer slightly to give the new window a moment to initialize its listener
      setTimeout(()=> {
        try {
          const initPayload = {
            type: 'init',
            payload: payload,
            timestamp: Date.now()
          };
          bc.postMessage(initPayload);
        } catch(err){
          console.warn('BroadcastChannel post failed', err);
        } finally {
          try { bc.close(); } catch(e){}
        }
      }, 150);
    }
  } catch(e){
    console.warn('BroadcastChannel unavailable', e);
  }
}

function exportResults(){
  const groups = document.getElementById('groupOutput').value;
  const order = document.getElementById('orderOutput').value;
  const roles = document.getElementById('rolesOutput').value;
  const blob = new Blob([`ã‚°ãƒ«ãƒ¼ãƒ—:\n${groups}\n\né †ç•ª:\n${order}\n\nå½¹å‰²:\n${roles}`], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = (document.getElementById('shareEventTitle').value || 'shuffly_result') + '.txt';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast("çµæœã‚’å‡ºåŠ›ã—ã¾ã—ãŸ");
}

function saveResults(){
  try{
    const membersRaw = getRawValue().trim().split(/[\r\n,]+/).map(s=>s.trim()).filter(Boolean);
    const entries = membersRaw.map(m=> parseEntry(m) );
    document.getElementById('membersJsonInput').value = JSON.stringify(entries);
  }catch(e){}

  if(!document.getElementById('resultsJsonInput').value){
    try { document.getElementById('resultsJsonInput').value = JSON.stringify({ groups: {}, group_names: {} }); } catch(e){}
  }
  if(!document.getElementById('settingsJsonInput').value){
    try {
      document.getElementById('settingsJsonInput').value = JSON.stringify({
        roles: document.getElementById('rolesInput') ? document.getElementById('rolesInput').value : '',
        group_count: (document.getElementById('groupCount') ? document.getElementById('groupCount').value : '')
      });
    } catch(e){}
  }
  if(!document.getElementById('orderJsonInput').value){
    try {
      const orderText = document.getElementById('orderOutput').value || '';
      const names = orderText.split(/\r?\n/).map(l=>l.replace(/^\d+\.\s*/,'')).filter(Boolean);
      document.getElementById('orderJsonInput').value = JSON.stringify(names.map((n,i)=>({name:n, order:i+1})));
    }catch(e){}
  }
  if(!document.getElementById('historyJsonInput').value){
    try{ document.getElementById('historyJsonInput').value=JSON.stringify(shufflyHistory); }catch(e){}
  }

  const titleField = document.getElementById('hiddenEventTitle');
  if(titleField) titleField.value = document.getElementById('shareEventTitle').value;

  const payloadPreview = {
    members_json: document.getElementById('membersJsonInput').value,
    results_json: document.getElementById('resultsJsonInput').value,
    order_json: document.getElementById('orderJsonInput').value,
    settings_json: document.getElementById('settingsJsonInput').value,
    history_json: document.getElementById('historyJsonInput').value,
    title: document.getElementById('hiddenEventTitle') ? document.getElementById('hiddenEventTitle').value : ''
  };

  if(IS_SIGNED_IN){
    const form = document.getElementById('saveForm');
    if(form) {
      form.submit();
    } else {
      showToast("ãƒ•ã‚©ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }
  } else {
    try {
      localStorage.setItem('pending_shuffly_event', JSON.stringify(payloadPreview));
      const loginUrl = "<%= new_user_session_path %>?redirect_to=" + encodeURIComponent(window.location.href);
      window.location.href = loginUrl;
    } catch(e){
      showToast("ä¿å­˜å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  }
}

// åˆæœŸåŒ– / ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰
window.onload = () => {
  const histField = document.getElementById('historyJsonInput');
  if(histField && histField.value){
    try {
      shufflyHistory = JSON.parse(histField.value);
      currentHistoryIndex = shufflyHistory.length - 1;
      if (currentHistoryIndex >= 0) {
        const val = shufflyHistory[currentHistoryIndex];
        setRawAndRefreshDisplay(val);
      }
    } catch(e) {
      shufflyHistory=[]; currentHistoryIndex=-1;
    }
  } else {
    // if no history stored, initialize display from membersRaw initial value
    updateDisplayFromRaw();
  }
  updateParticipantCount();
  if(shufflyHistory.length === 0) pushToHistory();
  switchResultTab('groups');
  switchSettingsTab('groups');

  // ensure stats collapsed state reflected on load
  const sc = document.getElementById('statsContainer');
  const btn = document.getElementById('btn-toggle-stats');
  if(sc && btn){
    if(statsCollapsed){
      sc.classList.add('hidden');
      btn.textContent = "çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º";
    } else {
      sc.classList.remove('hidden');
      btn.textContent = "çµ±è¨ˆæƒ…å ±ã‚’éè¡¨ç¤º";
    }
  }

  if(IS_SIGNED_IN){
    const pending = localStorage.getItem('pending_shuffly_event');
    if(pending){
      try {
        const p = JSON.parse(pending);
        if(p.members_json) document.getElementById('membersJsonInput').value = p.members_json;
        if(p.results_json) document.getElementById('resultsJsonInput').value = p.results_json;
        if(p.order_json) document.getElementById('orderJsonInput').value = p.order_json;
        if(p.settings_json) document.getElementById('settingsJsonInput').value = p.settings_json;
        if(p.history_json) document.getElementById('historyJsonInput').value = p.history_json;
        if(p.title && document.getElementById('hiddenEventTitle')) document.getElementById('hiddenEventTitle').value = p.title;
        const form = document.getElementById('saveForm');
        if(form){
          localStorage.removeItem('pending_shuffly_event');
          form.submit();
        }
      } catch(e){
        // ignore
      }
    }
  }
};

(function(){
  function bindIf(id, evt, handler){
    const el = document.getElementById(id);
    if(el) el.addEventListener(evt, handler);
  }

  // Visible membersInput: on user edit, parse back to raw and update hidden storage
  bindIf('membersInput', 'input', ()=>{
    if(suppressDisplayInput) return;
    const disp = getDisplayValue();
    const raw = parseDisplayToRaw(disp);
    setRawValue(raw);
    updateParticipantCount();
    pushToHistory();
  });

  bindIf('groupCount', 'input', ()=>{ updateParticipantCount(); /* do not auto-show groups/stats */ });
  bindIf('customGroupNames', 'input', ()=>{ updateParticipantCount(); /* reflect 1ã‚°ãƒ«ãƒ¼ãƒ—ã‚ãŸã‚Šäººæ•°ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–° */ });
  bindIf('rolesInput', 'input', ()=>{
    const settingsField = document.getElementById('settingsJsonInput');
    if(settingsField) settingsField.value=JSON.stringify({
      roles:document.getElementById('rolesInput').value,
      group_count: buildGroupIdsAndNames().groupCount
    });
  });

  // Import / paste (prevent default for link-style triggers)
  bindIf('btn-trigger-import', 'click', (e)=>{ e.preventDefault(); triggerImport(); });
  bindIf('importFile', 'change', handleImportFile);
  bindIf('btn-paste-clipboard', 'click', (e)=>{ e.preventDefault(); pasteFromClipboard(); });
  bindIf('btn-clear-history', 'click', (e)=>{ e.preventDefault(); clearMemberHistories(); });

  // Settings tabs
  bindIf('tab-settings-groups', 'click', ()=>switchSettingsTab('groups'));
  bindIf('tab-settings-order', 'click', ()=>switchSettingsTab('order'));
  bindIf('tab-settings-roles', 'click', ()=>switchSettingsTab('roles'));

  // Result tabs
  bindIf('tab-groups', 'click', ()=>switchResultTab('groups'));
  bindIf('tab-order', 'click', ()=>switchResultTab('order'));
  bindIf('tab-roles', 'click', ()=>switchResultTab('roles'));

  // Group view controls: SPAã§å³æ™‚åæ˜ 
  bindIf('showGroupLabel', 'change', ()=>{ showGroups(); showStats(); });
  bindIf('showGroupCount', 'change', ()=>{ showGroups(); showStats(); });
  bindIf('breakMemberLine', 'change', ()=>{ showGroups(); });
  bindIf('separatorSelect', 'change', ()=>{ showGroups(); showStats(); });
  bindIf('groupSeparatorSelect', 'change', ()=>{ showGroups(); showStats(); });

  bindIf('btn-copy-groupoutput', 'click', (e)=>{ e.preventDefault(); copyGroupOutput(); });
  bindIf('btn-copy-orderoutput', 'click', (e)=>{ e.preventDefault(); copyOrderOutput(); });
  bindIf('btn-copy-rolesoutput', 'click', (e)=>{ e.preventDefault(); copyRolesOutput(); });

  // Toggle stats visibility (default collapsed)
  bindIf('btn-toggle-stats', 'click', (e)=>{
    if(e) e.preventDefault();
    const sc = document.getElementById('statsContainer');
    const btn = document.getElementById('btn-toggle-stats');
    if(!sc || !btn) return;
    sc.classList.toggle('hidden');
    statsCollapsed = sc.classList.contains('hidden');
    btn.textContent = statsCollapsed ? "çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º" : "çµ±è¨ˆæƒ…å ±ã‚’éè¡¨ç¤º";
    // update stats content whenever opened
    if(!statsCollapsed) showStats();
  });

  // Prev/Next links in results card (moved from settings area; same functionality, link style)
  bindIf('btn-prev-group', 'click', (e)=>{
    if(e) e.preventDefault();
    if(currentHistoryIndex <= 0){
      showToast("ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“");
      return;
    }
    undoHistory();
  });
  bindIf('btn-next-group', 'click', (e)=>{
    if(e) e.preventDefault();
    if(currentHistoryIndex >= shufflyHistory.length-1){
      showToast("ã“ã‚Œä»¥ä¸Šé€²ã‚ã¾ã›ã‚“");
      return;
    }
    redoHistory();
  });

  // Share controls
  bindIf('btn-toggle-presentation', 'click', (e)=>{ if(e) e.preventDefault(); togglePresentationMode(); });
  bindIf('btn-export-results', 'click', (e)=>{ if(e) e.preventDefault(); exportResults(); });
  bindIf('btn-save-results', 'click', (e)=>{ if(e) e.preventDefault(); saveResults(); });

  // Settings action buttons (find within containers and attach in order)
  const gAct = document.getElementById('settings-action-groups');
  if (gAct) {
    const btns = gAct.querySelectorAll('button, a[role="button"], a');
    if (btns[0]) btns[0].addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignGroups(); /* SPA: update panels without reload */ });
    // prev/next moved to results links
  }
  const oAct = document.getElementById('settings-action-order');
  if (oAct) {
    const b = oAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignOrder(); /* SPA: show order panel */ });
  }
  const rAct = document.getElementById('settings-action-roles');
  if (rAct) {
    const b = rAct.querySelector('button, a[role="button"], a');
    if (b) b.addEventListener('click', (e)=>{ if(e) e.preventDefault(); assignRoles(); /* SPA: show roles panel */ });
  }
})();
</script>